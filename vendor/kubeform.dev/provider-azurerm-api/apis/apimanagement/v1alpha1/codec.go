/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration{}).Type1()): ApiManagementSpecAdditionalLocationVirtualNetworkConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecHostnameConfiguration{}).Type1()):                         ApiManagementSpecHostnameConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecIdentity{}).Type1()):                                      ApiManagementSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecPolicy{}).Type1()):                                        ApiManagementSpecPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecProtocols{}).Type1()):                                     ApiManagementSpecProtocolsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSecurity{}).Type1()):                                      ApiManagementSpecSecurityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignIn{}).Type1()):                                        ApiManagementSpecSignInCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignUp{}).Type1()):                                        ApiManagementSpecSignUpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignUpTermsOfService{}).Type1()):                          ApiManagementSpecSignUpTermsOfServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecTenantAccess{}).Type1()):                                  ApiManagementSpecTenantAccessCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecVirtualNetworkConfiguration{}).Type1()):                   ApiManagementSpecVirtualNetworkConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecImport{}).Type1()):                                                  ApiSpecImportCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecImportWsdlSelector{}).Type1()):                                      ApiSpecImportWsdlSelectorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecOauth2Authorization{}).Type1()):                                     ApiSpecOauth2AuthorizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecOpenidAuthentication{}).Type1()):                                    ApiSpecOpenidAuthenticationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecSubscriptionKeyParameterNames{}).Type1()):                           ApiSpecSubscriptionKeyParameterNamesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendRequest{}).Type1()):                                ApiDiagnosticSpecBackendRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendRequestDataMasking{}).Type1()):                     ApiDiagnosticSpecBackendRequestDataMaskingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendResponse{}).Type1()):                               ApiDiagnosticSpecBackendResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendResponseDataMasking{}).Type1()):                    ApiDiagnosticSpecBackendResponseDataMaskingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendRequest{}).Type1()):                               ApiDiagnosticSpecFrontendRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendRequestDataMasking{}).Type1()):                    ApiDiagnosticSpecFrontendRequestDataMaskingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendResponse{}).Type1()):                              ApiDiagnosticSpecFrontendResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendResponseDataMasking{}).Type1()):                   ApiDiagnosticSpecFrontendResponseDataMaskingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiOperationSpecRequest{}).Type1()):                                        ApiOperationSpecRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecCredentials{}).Type1()):                                         BackendSpecCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecCredentialsAuthorization{}).Type1()):                            BackendSpecCredentialsAuthorizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecProxy{}).Type1()):                                               BackendSpecProxyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecServiceFabricCluster{}).Type1()):                                BackendSpecServiceFabricClusterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecTls{}).Type1()):                                                 BackendSpecTlsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendRequest{}).Type1()):                                   DiagnosticSpecBackendRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendRequestDataMasking{}).Type1()):                        DiagnosticSpecBackendRequestDataMaskingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendResponse{}).Type1()):                                  DiagnosticSpecBackendResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendResponseDataMasking{}).Type1()):                       DiagnosticSpecBackendResponseDataMaskingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendRequest{}).Type1()):                                  DiagnosticSpecFrontendRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendRequestDataMasking{}).Type1()):                       DiagnosticSpecFrontendRequestDataMaskingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendResponse{}).Type1()):                                 DiagnosticSpecFrontendResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendResponseDataMasking{}).Type1()):                      DiagnosticSpecFrontendResponseDataMaskingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewaySpecLocationData{}).Type1()):                                        GatewaySpecLocationDataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LoggerSpecApplicationInsights{}).Type1()):                                  LoggerSpecApplicationInsightsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LoggerSpecEventhub{}).Type1()):                                             LoggerSpecEventhubCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamedValueSpecValueFromKeyVault{}).Type1()):                                NamedValueSpecValueFromKeyVaultCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration{}).Type1()): ApiManagementSpecAdditionalLocationVirtualNetworkConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecHostnameConfiguration{}).Type1()):                         ApiManagementSpecHostnameConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecIdentity{}).Type1()):                                      ApiManagementSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecPolicy{}).Type1()):                                        ApiManagementSpecPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecProtocols{}).Type1()):                                     ApiManagementSpecProtocolsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSecurity{}).Type1()):                                      ApiManagementSpecSecurityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignIn{}).Type1()):                                        ApiManagementSpecSignInCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignUp{}).Type1()):                                        ApiManagementSpecSignUpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignUpTermsOfService{}).Type1()):                          ApiManagementSpecSignUpTermsOfServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecTenantAccess{}).Type1()):                                  ApiManagementSpecTenantAccessCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecVirtualNetworkConfiguration{}).Type1()):                   ApiManagementSpecVirtualNetworkConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecImport{}).Type1()):                                                  ApiSpecImportCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecImportWsdlSelector{}).Type1()):                                      ApiSpecImportWsdlSelectorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecOauth2Authorization{}).Type1()):                                     ApiSpecOauth2AuthorizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecOpenidAuthentication{}).Type1()):                                    ApiSpecOpenidAuthenticationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecSubscriptionKeyParameterNames{}).Type1()):                           ApiSpecSubscriptionKeyParameterNamesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendRequest{}).Type1()):                                ApiDiagnosticSpecBackendRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendRequestDataMasking{}).Type1()):                     ApiDiagnosticSpecBackendRequestDataMaskingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendResponse{}).Type1()):                               ApiDiagnosticSpecBackendResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendResponseDataMasking{}).Type1()):                    ApiDiagnosticSpecBackendResponseDataMaskingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendRequest{}).Type1()):                               ApiDiagnosticSpecFrontendRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendRequestDataMasking{}).Type1()):                    ApiDiagnosticSpecFrontendRequestDataMaskingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendResponse{}).Type1()):                              ApiDiagnosticSpecFrontendResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendResponseDataMasking{}).Type1()):                   ApiDiagnosticSpecFrontendResponseDataMaskingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiOperationSpecRequest{}).Type1()):                                        ApiOperationSpecRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecCredentials{}).Type1()):                                         BackendSpecCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecCredentialsAuthorization{}).Type1()):                            BackendSpecCredentialsAuthorizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecProxy{}).Type1()):                                               BackendSpecProxyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecServiceFabricCluster{}).Type1()):                                BackendSpecServiceFabricClusterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecTls{}).Type1()):                                                 BackendSpecTlsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendRequest{}).Type1()):                                   DiagnosticSpecBackendRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendRequestDataMasking{}).Type1()):                        DiagnosticSpecBackendRequestDataMaskingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendResponse{}).Type1()):                                  DiagnosticSpecBackendResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendResponseDataMasking{}).Type1()):                       DiagnosticSpecBackendResponseDataMaskingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendRequest{}).Type1()):                                  DiagnosticSpecFrontendRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendRequestDataMasking{}).Type1()):                       DiagnosticSpecFrontendRequestDataMaskingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendResponse{}).Type1()):                                 DiagnosticSpecFrontendResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendResponseDataMasking{}).Type1()):                      DiagnosticSpecFrontendResponseDataMaskingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewaySpecLocationData{}).Type1()):                                        GatewaySpecLocationDataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LoggerSpecApplicationInsights{}).Type1()):                                  LoggerSpecApplicationInsightsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LoggerSpecEventhub{}).Type1()):                                             LoggerSpecEventhubCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamedValueSpecValueFromKeyVault{}).Type1()):                                NamedValueSpecValueFromKeyVaultCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecAdditionalLocationVirtualNetworkConfigurationCodec struct {
}

func (ApiManagementSpecAdditionalLocationVirtualNetworkConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration)(ptr) == nil
}

func (ApiManagementSpecAdditionalLocationVirtualNetworkConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration)(ptr)
	var objs []ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration
	if obj != nil {
		objs = []ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecAdditionalLocationVirtualNetworkConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration)(ptr) = ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration)(ptr) = ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration{}
			}
		} else {
			*(*ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration)(ptr) = ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration)(ptr) = obj
		} else {
			*(*ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration)(ptr) = ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecHostnameConfigurationCodec struct {
}

func (ApiManagementSpecHostnameConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecHostnameConfiguration)(ptr) == nil
}

func (ApiManagementSpecHostnameConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecHostnameConfiguration)(ptr)
	var objs []ApiManagementSpecHostnameConfiguration
	if obj != nil {
		objs = []ApiManagementSpecHostnameConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecHostnameConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecHostnameConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecHostnameConfiguration)(ptr) = ApiManagementSpecHostnameConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecHostnameConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecHostnameConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecHostnameConfiguration)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecHostnameConfiguration)(ptr) = ApiManagementSpecHostnameConfiguration{}
			}
		} else {
			*(*ApiManagementSpecHostnameConfiguration)(ptr) = ApiManagementSpecHostnameConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiManagementSpecHostnameConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecHostnameConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiManagementSpecHostnameConfiguration)(ptr) = obj
		} else {
			*(*ApiManagementSpecHostnameConfiguration)(ptr) = ApiManagementSpecHostnameConfiguration{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecHostnameConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecIdentityCodec struct {
}

func (ApiManagementSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecIdentity)(ptr) == nil
}

func (ApiManagementSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecIdentity)(ptr)
	var objs []ApiManagementSpecIdentity
	if obj != nil {
		objs = []ApiManagementSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecIdentity)(ptr) = ApiManagementSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecIdentity)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecIdentity)(ptr) = ApiManagementSpecIdentity{}
			}
		} else {
			*(*ApiManagementSpecIdentity)(ptr) = ApiManagementSpecIdentity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiManagementSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiManagementSpecIdentity)(ptr) = obj
		} else {
			*(*ApiManagementSpecIdentity)(ptr) = ApiManagementSpecIdentity{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecPolicyCodec struct {
}

func (ApiManagementSpecPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecPolicy)(ptr) == nil
}

func (ApiManagementSpecPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecPolicy)(ptr)
	var objs []ApiManagementSpecPolicy
	if obj != nil {
		objs = []ApiManagementSpecPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecPolicy)(ptr) = ApiManagementSpecPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecPolicy)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecPolicy)(ptr) = ApiManagementSpecPolicy{}
			}
		} else {
			*(*ApiManagementSpecPolicy)(ptr) = ApiManagementSpecPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiManagementSpecPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiManagementSpecPolicy)(ptr) = obj
		} else {
			*(*ApiManagementSpecPolicy)(ptr) = ApiManagementSpecPolicy{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecProtocolsCodec struct {
}

func (ApiManagementSpecProtocolsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecProtocols)(ptr) == nil
}

func (ApiManagementSpecProtocolsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecProtocols)(ptr)
	var objs []ApiManagementSpecProtocols
	if obj != nil {
		objs = []ApiManagementSpecProtocols{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecProtocols{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecProtocolsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecProtocols)(ptr) = ApiManagementSpecProtocols{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecProtocols

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecProtocols{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecProtocols)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecProtocols)(ptr) = ApiManagementSpecProtocols{}
			}
		} else {
			*(*ApiManagementSpecProtocols)(ptr) = ApiManagementSpecProtocols{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiManagementSpecProtocols

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecProtocols{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiManagementSpecProtocols)(ptr) = obj
		} else {
			*(*ApiManagementSpecProtocols)(ptr) = ApiManagementSpecProtocols{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecProtocols", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecSecurityCodec struct {
}

func (ApiManagementSpecSecurityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecSecurity)(ptr) == nil
}

func (ApiManagementSpecSecurityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecSecurity)(ptr)
	var objs []ApiManagementSpecSecurity
	if obj != nil {
		objs = []ApiManagementSpecSecurity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSecurity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecSecurityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecSecurity)(ptr) = ApiManagementSpecSecurity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecSecurity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSecurity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecSecurity)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecSecurity)(ptr) = ApiManagementSpecSecurity{}
			}
		} else {
			*(*ApiManagementSpecSecurity)(ptr) = ApiManagementSpecSecurity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiManagementSpecSecurity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSecurity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiManagementSpecSecurity)(ptr) = obj
		} else {
			*(*ApiManagementSpecSecurity)(ptr) = ApiManagementSpecSecurity{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecSecurity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecSignInCodec struct {
}

func (ApiManagementSpecSignInCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecSignIn)(ptr) == nil
}

func (ApiManagementSpecSignInCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecSignIn)(ptr)
	var objs []ApiManagementSpecSignIn
	if obj != nil {
		objs = []ApiManagementSpecSignIn{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignIn{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecSignInCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecSignIn)(ptr) = ApiManagementSpecSignIn{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecSignIn

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignIn{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecSignIn)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecSignIn)(ptr) = ApiManagementSpecSignIn{}
			}
		} else {
			*(*ApiManagementSpecSignIn)(ptr) = ApiManagementSpecSignIn{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiManagementSpecSignIn

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignIn{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiManagementSpecSignIn)(ptr) = obj
		} else {
			*(*ApiManagementSpecSignIn)(ptr) = ApiManagementSpecSignIn{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecSignIn", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecSignUpCodec struct {
}

func (ApiManagementSpecSignUpCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecSignUp)(ptr) == nil
}

func (ApiManagementSpecSignUpCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecSignUp)(ptr)
	var objs []ApiManagementSpecSignUp
	if obj != nil {
		objs = []ApiManagementSpecSignUp{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignUp{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecSignUpCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecSignUp)(ptr) = ApiManagementSpecSignUp{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecSignUp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignUp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecSignUp)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecSignUp)(ptr) = ApiManagementSpecSignUp{}
			}
		} else {
			*(*ApiManagementSpecSignUp)(ptr) = ApiManagementSpecSignUp{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiManagementSpecSignUp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignUp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiManagementSpecSignUp)(ptr) = obj
		} else {
			*(*ApiManagementSpecSignUp)(ptr) = ApiManagementSpecSignUp{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecSignUp", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecSignUpTermsOfServiceCodec struct {
}

func (ApiManagementSpecSignUpTermsOfServiceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecSignUpTermsOfService)(ptr) == nil
}

func (ApiManagementSpecSignUpTermsOfServiceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecSignUpTermsOfService)(ptr)
	var objs []ApiManagementSpecSignUpTermsOfService
	if obj != nil {
		objs = []ApiManagementSpecSignUpTermsOfService{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignUpTermsOfService{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecSignUpTermsOfServiceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecSignUpTermsOfService)(ptr) = ApiManagementSpecSignUpTermsOfService{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecSignUpTermsOfService

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignUpTermsOfService{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecSignUpTermsOfService)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecSignUpTermsOfService)(ptr) = ApiManagementSpecSignUpTermsOfService{}
			}
		} else {
			*(*ApiManagementSpecSignUpTermsOfService)(ptr) = ApiManagementSpecSignUpTermsOfService{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiManagementSpecSignUpTermsOfService

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignUpTermsOfService{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiManagementSpecSignUpTermsOfService)(ptr) = obj
		} else {
			*(*ApiManagementSpecSignUpTermsOfService)(ptr) = ApiManagementSpecSignUpTermsOfService{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecSignUpTermsOfService", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecTenantAccessCodec struct {
}

func (ApiManagementSpecTenantAccessCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecTenantAccess)(ptr) == nil
}

func (ApiManagementSpecTenantAccessCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecTenantAccess)(ptr)
	var objs []ApiManagementSpecTenantAccess
	if obj != nil {
		objs = []ApiManagementSpecTenantAccess{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecTenantAccess{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecTenantAccessCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecTenantAccess)(ptr) = ApiManagementSpecTenantAccess{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecTenantAccess

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecTenantAccess{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecTenantAccess)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecTenantAccess)(ptr) = ApiManagementSpecTenantAccess{}
			}
		} else {
			*(*ApiManagementSpecTenantAccess)(ptr) = ApiManagementSpecTenantAccess{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiManagementSpecTenantAccess

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecTenantAccess{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiManagementSpecTenantAccess)(ptr) = obj
		} else {
			*(*ApiManagementSpecTenantAccess)(ptr) = ApiManagementSpecTenantAccess{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecTenantAccess", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecVirtualNetworkConfigurationCodec struct {
}

func (ApiManagementSpecVirtualNetworkConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecVirtualNetworkConfiguration)(ptr) == nil
}

func (ApiManagementSpecVirtualNetworkConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecVirtualNetworkConfiguration)(ptr)
	var objs []ApiManagementSpecVirtualNetworkConfiguration
	if obj != nil {
		objs = []ApiManagementSpecVirtualNetworkConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecVirtualNetworkConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecVirtualNetworkConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecVirtualNetworkConfiguration)(ptr) = ApiManagementSpecVirtualNetworkConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecVirtualNetworkConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecVirtualNetworkConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecVirtualNetworkConfiguration)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecVirtualNetworkConfiguration)(ptr) = ApiManagementSpecVirtualNetworkConfiguration{}
			}
		} else {
			*(*ApiManagementSpecVirtualNetworkConfiguration)(ptr) = ApiManagementSpecVirtualNetworkConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiManagementSpecVirtualNetworkConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecVirtualNetworkConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiManagementSpecVirtualNetworkConfiguration)(ptr) = obj
		} else {
			*(*ApiManagementSpecVirtualNetworkConfiguration)(ptr) = ApiManagementSpecVirtualNetworkConfiguration{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecVirtualNetworkConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiSpecImportCodec struct {
}

func (ApiSpecImportCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiSpecImport)(ptr) == nil
}

func (ApiSpecImportCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiSpecImport)(ptr)
	var objs []ApiSpecImport
	if obj != nil {
		objs = []ApiSpecImport{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecImport{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiSpecImportCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiSpecImport)(ptr) = ApiSpecImport{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiSpecImport

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecImport{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiSpecImport)(ptr) = objs[0]
			} else {
				*(*ApiSpecImport)(ptr) = ApiSpecImport{}
			}
		} else {
			*(*ApiSpecImport)(ptr) = ApiSpecImport{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiSpecImport

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecImport{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiSpecImport)(ptr) = obj
		} else {
			*(*ApiSpecImport)(ptr) = ApiSpecImport{}
		}
	default:
		iter.ReportError("decode ApiSpecImport", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiSpecImportWsdlSelectorCodec struct {
}

func (ApiSpecImportWsdlSelectorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiSpecImportWsdlSelector)(ptr) == nil
}

func (ApiSpecImportWsdlSelectorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiSpecImportWsdlSelector)(ptr)
	var objs []ApiSpecImportWsdlSelector
	if obj != nil {
		objs = []ApiSpecImportWsdlSelector{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecImportWsdlSelector{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiSpecImportWsdlSelectorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiSpecImportWsdlSelector)(ptr) = ApiSpecImportWsdlSelector{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiSpecImportWsdlSelector

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecImportWsdlSelector{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiSpecImportWsdlSelector)(ptr) = objs[0]
			} else {
				*(*ApiSpecImportWsdlSelector)(ptr) = ApiSpecImportWsdlSelector{}
			}
		} else {
			*(*ApiSpecImportWsdlSelector)(ptr) = ApiSpecImportWsdlSelector{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiSpecImportWsdlSelector

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecImportWsdlSelector{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiSpecImportWsdlSelector)(ptr) = obj
		} else {
			*(*ApiSpecImportWsdlSelector)(ptr) = ApiSpecImportWsdlSelector{}
		}
	default:
		iter.ReportError("decode ApiSpecImportWsdlSelector", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiSpecOauth2AuthorizationCodec struct {
}

func (ApiSpecOauth2AuthorizationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiSpecOauth2Authorization)(ptr) == nil
}

func (ApiSpecOauth2AuthorizationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiSpecOauth2Authorization)(ptr)
	var objs []ApiSpecOauth2Authorization
	if obj != nil {
		objs = []ApiSpecOauth2Authorization{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecOauth2Authorization{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiSpecOauth2AuthorizationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiSpecOauth2Authorization)(ptr) = ApiSpecOauth2Authorization{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiSpecOauth2Authorization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecOauth2Authorization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiSpecOauth2Authorization)(ptr) = objs[0]
			} else {
				*(*ApiSpecOauth2Authorization)(ptr) = ApiSpecOauth2Authorization{}
			}
		} else {
			*(*ApiSpecOauth2Authorization)(ptr) = ApiSpecOauth2Authorization{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiSpecOauth2Authorization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecOauth2Authorization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiSpecOauth2Authorization)(ptr) = obj
		} else {
			*(*ApiSpecOauth2Authorization)(ptr) = ApiSpecOauth2Authorization{}
		}
	default:
		iter.ReportError("decode ApiSpecOauth2Authorization", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiSpecOpenidAuthenticationCodec struct {
}

func (ApiSpecOpenidAuthenticationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiSpecOpenidAuthentication)(ptr) == nil
}

func (ApiSpecOpenidAuthenticationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiSpecOpenidAuthentication)(ptr)
	var objs []ApiSpecOpenidAuthentication
	if obj != nil {
		objs = []ApiSpecOpenidAuthentication{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecOpenidAuthentication{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiSpecOpenidAuthenticationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiSpecOpenidAuthentication)(ptr) = ApiSpecOpenidAuthentication{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiSpecOpenidAuthentication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecOpenidAuthentication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiSpecOpenidAuthentication)(ptr) = objs[0]
			} else {
				*(*ApiSpecOpenidAuthentication)(ptr) = ApiSpecOpenidAuthentication{}
			}
		} else {
			*(*ApiSpecOpenidAuthentication)(ptr) = ApiSpecOpenidAuthentication{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiSpecOpenidAuthentication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecOpenidAuthentication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiSpecOpenidAuthentication)(ptr) = obj
		} else {
			*(*ApiSpecOpenidAuthentication)(ptr) = ApiSpecOpenidAuthentication{}
		}
	default:
		iter.ReportError("decode ApiSpecOpenidAuthentication", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiSpecSubscriptionKeyParameterNamesCodec struct {
}

func (ApiSpecSubscriptionKeyParameterNamesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiSpecSubscriptionKeyParameterNames)(ptr) == nil
}

func (ApiSpecSubscriptionKeyParameterNamesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiSpecSubscriptionKeyParameterNames)(ptr)
	var objs []ApiSpecSubscriptionKeyParameterNames
	if obj != nil {
		objs = []ApiSpecSubscriptionKeyParameterNames{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecSubscriptionKeyParameterNames{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiSpecSubscriptionKeyParameterNamesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiSpecSubscriptionKeyParameterNames)(ptr) = ApiSpecSubscriptionKeyParameterNames{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiSpecSubscriptionKeyParameterNames

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecSubscriptionKeyParameterNames{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiSpecSubscriptionKeyParameterNames)(ptr) = objs[0]
			} else {
				*(*ApiSpecSubscriptionKeyParameterNames)(ptr) = ApiSpecSubscriptionKeyParameterNames{}
			}
		} else {
			*(*ApiSpecSubscriptionKeyParameterNames)(ptr) = ApiSpecSubscriptionKeyParameterNames{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiSpecSubscriptionKeyParameterNames

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecSubscriptionKeyParameterNames{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiSpecSubscriptionKeyParameterNames)(ptr) = obj
		} else {
			*(*ApiSpecSubscriptionKeyParameterNames)(ptr) = ApiSpecSubscriptionKeyParameterNames{}
		}
	default:
		iter.ReportError("decode ApiSpecSubscriptionKeyParameterNames", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiDiagnosticSpecBackendRequestCodec struct {
}

func (ApiDiagnosticSpecBackendRequestCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiDiagnosticSpecBackendRequest)(ptr) == nil
}

func (ApiDiagnosticSpecBackendRequestCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiDiagnosticSpecBackendRequest)(ptr)
	var objs []ApiDiagnosticSpecBackendRequest
	if obj != nil {
		objs = []ApiDiagnosticSpecBackendRequest{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendRequest{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiDiagnosticSpecBackendRequestCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiDiagnosticSpecBackendRequest)(ptr) = ApiDiagnosticSpecBackendRequest{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiDiagnosticSpecBackendRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiDiagnosticSpecBackendRequest)(ptr) = objs[0]
			} else {
				*(*ApiDiagnosticSpecBackendRequest)(ptr) = ApiDiagnosticSpecBackendRequest{}
			}
		} else {
			*(*ApiDiagnosticSpecBackendRequest)(ptr) = ApiDiagnosticSpecBackendRequest{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiDiagnosticSpecBackendRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiDiagnosticSpecBackendRequest)(ptr) = obj
		} else {
			*(*ApiDiagnosticSpecBackendRequest)(ptr) = ApiDiagnosticSpecBackendRequest{}
		}
	default:
		iter.ReportError("decode ApiDiagnosticSpecBackendRequest", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiDiagnosticSpecBackendRequestDataMaskingCodec struct {
}

func (ApiDiagnosticSpecBackendRequestDataMaskingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiDiagnosticSpecBackendRequestDataMasking)(ptr) == nil
}

func (ApiDiagnosticSpecBackendRequestDataMaskingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiDiagnosticSpecBackendRequestDataMasking)(ptr)
	var objs []ApiDiagnosticSpecBackendRequestDataMasking
	if obj != nil {
		objs = []ApiDiagnosticSpecBackendRequestDataMasking{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendRequestDataMasking{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiDiagnosticSpecBackendRequestDataMaskingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiDiagnosticSpecBackendRequestDataMasking)(ptr) = ApiDiagnosticSpecBackendRequestDataMasking{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiDiagnosticSpecBackendRequestDataMasking

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendRequestDataMasking{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiDiagnosticSpecBackendRequestDataMasking)(ptr) = objs[0]
			} else {
				*(*ApiDiagnosticSpecBackendRequestDataMasking)(ptr) = ApiDiagnosticSpecBackendRequestDataMasking{}
			}
		} else {
			*(*ApiDiagnosticSpecBackendRequestDataMasking)(ptr) = ApiDiagnosticSpecBackendRequestDataMasking{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiDiagnosticSpecBackendRequestDataMasking

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendRequestDataMasking{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiDiagnosticSpecBackendRequestDataMasking)(ptr) = obj
		} else {
			*(*ApiDiagnosticSpecBackendRequestDataMasking)(ptr) = ApiDiagnosticSpecBackendRequestDataMasking{}
		}
	default:
		iter.ReportError("decode ApiDiagnosticSpecBackendRequestDataMasking", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiDiagnosticSpecBackendResponseCodec struct {
}

func (ApiDiagnosticSpecBackendResponseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiDiagnosticSpecBackendResponse)(ptr) == nil
}

func (ApiDiagnosticSpecBackendResponseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiDiagnosticSpecBackendResponse)(ptr)
	var objs []ApiDiagnosticSpecBackendResponse
	if obj != nil {
		objs = []ApiDiagnosticSpecBackendResponse{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendResponse{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiDiagnosticSpecBackendResponseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiDiagnosticSpecBackendResponse)(ptr) = ApiDiagnosticSpecBackendResponse{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiDiagnosticSpecBackendResponse

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendResponse{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiDiagnosticSpecBackendResponse)(ptr) = objs[0]
			} else {
				*(*ApiDiagnosticSpecBackendResponse)(ptr) = ApiDiagnosticSpecBackendResponse{}
			}
		} else {
			*(*ApiDiagnosticSpecBackendResponse)(ptr) = ApiDiagnosticSpecBackendResponse{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiDiagnosticSpecBackendResponse

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendResponse{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiDiagnosticSpecBackendResponse)(ptr) = obj
		} else {
			*(*ApiDiagnosticSpecBackendResponse)(ptr) = ApiDiagnosticSpecBackendResponse{}
		}
	default:
		iter.ReportError("decode ApiDiagnosticSpecBackendResponse", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiDiagnosticSpecBackendResponseDataMaskingCodec struct {
}

func (ApiDiagnosticSpecBackendResponseDataMaskingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiDiagnosticSpecBackendResponseDataMasking)(ptr) == nil
}

func (ApiDiagnosticSpecBackendResponseDataMaskingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiDiagnosticSpecBackendResponseDataMasking)(ptr)
	var objs []ApiDiagnosticSpecBackendResponseDataMasking
	if obj != nil {
		objs = []ApiDiagnosticSpecBackendResponseDataMasking{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendResponseDataMasking{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiDiagnosticSpecBackendResponseDataMaskingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiDiagnosticSpecBackendResponseDataMasking)(ptr) = ApiDiagnosticSpecBackendResponseDataMasking{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiDiagnosticSpecBackendResponseDataMasking

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendResponseDataMasking{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiDiagnosticSpecBackendResponseDataMasking)(ptr) = objs[0]
			} else {
				*(*ApiDiagnosticSpecBackendResponseDataMasking)(ptr) = ApiDiagnosticSpecBackendResponseDataMasking{}
			}
		} else {
			*(*ApiDiagnosticSpecBackendResponseDataMasking)(ptr) = ApiDiagnosticSpecBackendResponseDataMasking{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiDiagnosticSpecBackendResponseDataMasking

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendResponseDataMasking{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiDiagnosticSpecBackendResponseDataMasking)(ptr) = obj
		} else {
			*(*ApiDiagnosticSpecBackendResponseDataMasking)(ptr) = ApiDiagnosticSpecBackendResponseDataMasking{}
		}
	default:
		iter.ReportError("decode ApiDiagnosticSpecBackendResponseDataMasking", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiDiagnosticSpecFrontendRequestCodec struct {
}

func (ApiDiagnosticSpecFrontendRequestCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiDiagnosticSpecFrontendRequest)(ptr) == nil
}

func (ApiDiagnosticSpecFrontendRequestCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiDiagnosticSpecFrontendRequest)(ptr)
	var objs []ApiDiagnosticSpecFrontendRequest
	if obj != nil {
		objs = []ApiDiagnosticSpecFrontendRequest{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendRequest{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiDiagnosticSpecFrontendRequestCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiDiagnosticSpecFrontendRequest)(ptr) = ApiDiagnosticSpecFrontendRequest{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiDiagnosticSpecFrontendRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiDiagnosticSpecFrontendRequest)(ptr) = objs[0]
			} else {
				*(*ApiDiagnosticSpecFrontendRequest)(ptr) = ApiDiagnosticSpecFrontendRequest{}
			}
		} else {
			*(*ApiDiagnosticSpecFrontendRequest)(ptr) = ApiDiagnosticSpecFrontendRequest{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiDiagnosticSpecFrontendRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiDiagnosticSpecFrontendRequest)(ptr) = obj
		} else {
			*(*ApiDiagnosticSpecFrontendRequest)(ptr) = ApiDiagnosticSpecFrontendRequest{}
		}
	default:
		iter.ReportError("decode ApiDiagnosticSpecFrontendRequest", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiDiagnosticSpecFrontendRequestDataMaskingCodec struct {
}

func (ApiDiagnosticSpecFrontendRequestDataMaskingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiDiagnosticSpecFrontendRequestDataMasking)(ptr) == nil
}

func (ApiDiagnosticSpecFrontendRequestDataMaskingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiDiagnosticSpecFrontendRequestDataMasking)(ptr)
	var objs []ApiDiagnosticSpecFrontendRequestDataMasking
	if obj != nil {
		objs = []ApiDiagnosticSpecFrontendRequestDataMasking{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendRequestDataMasking{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiDiagnosticSpecFrontendRequestDataMaskingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiDiagnosticSpecFrontendRequestDataMasking)(ptr) = ApiDiagnosticSpecFrontendRequestDataMasking{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiDiagnosticSpecFrontendRequestDataMasking

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendRequestDataMasking{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiDiagnosticSpecFrontendRequestDataMasking)(ptr) = objs[0]
			} else {
				*(*ApiDiagnosticSpecFrontendRequestDataMasking)(ptr) = ApiDiagnosticSpecFrontendRequestDataMasking{}
			}
		} else {
			*(*ApiDiagnosticSpecFrontendRequestDataMasking)(ptr) = ApiDiagnosticSpecFrontendRequestDataMasking{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiDiagnosticSpecFrontendRequestDataMasking

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendRequestDataMasking{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiDiagnosticSpecFrontendRequestDataMasking)(ptr) = obj
		} else {
			*(*ApiDiagnosticSpecFrontendRequestDataMasking)(ptr) = ApiDiagnosticSpecFrontendRequestDataMasking{}
		}
	default:
		iter.ReportError("decode ApiDiagnosticSpecFrontendRequestDataMasking", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiDiagnosticSpecFrontendResponseCodec struct {
}

func (ApiDiagnosticSpecFrontendResponseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiDiagnosticSpecFrontendResponse)(ptr) == nil
}

func (ApiDiagnosticSpecFrontendResponseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiDiagnosticSpecFrontendResponse)(ptr)
	var objs []ApiDiagnosticSpecFrontendResponse
	if obj != nil {
		objs = []ApiDiagnosticSpecFrontendResponse{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendResponse{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiDiagnosticSpecFrontendResponseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiDiagnosticSpecFrontendResponse)(ptr) = ApiDiagnosticSpecFrontendResponse{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiDiagnosticSpecFrontendResponse

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendResponse{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiDiagnosticSpecFrontendResponse)(ptr) = objs[0]
			} else {
				*(*ApiDiagnosticSpecFrontendResponse)(ptr) = ApiDiagnosticSpecFrontendResponse{}
			}
		} else {
			*(*ApiDiagnosticSpecFrontendResponse)(ptr) = ApiDiagnosticSpecFrontendResponse{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiDiagnosticSpecFrontendResponse

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendResponse{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiDiagnosticSpecFrontendResponse)(ptr) = obj
		} else {
			*(*ApiDiagnosticSpecFrontendResponse)(ptr) = ApiDiagnosticSpecFrontendResponse{}
		}
	default:
		iter.ReportError("decode ApiDiagnosticSpecFrontendResponse", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiDiagnosticSpecFrontendResponseDataMaskingCodec struct {
}

func (ApiDiagnosticSpecFrontendResponseDataMaskingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiDiagnosticSpecFrontendResponseDataMasking)(ptr) == nil
}

func (ApiDiagnosticSpecFrontendResponseDataMaskingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiDiagnosticSpecFrontendResponseDataMasking)(ptr)
	var objs []ApiDiagnosticSpecFrontendResponseDataMasking
	if obj != nil {
		objs = []ApiDiagnosticSpecFrontendResponseDataMasking{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendResponseDataMasking{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiDiagnosticSpecFrontendResponseDataMaskingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiDiagnosticSpecFrontendResponseDataMasking)(ptr) = ApiDiagnosticSpecFrontendResponseDataMasking{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiDiagnosticSpecFrontendResponseDataMasking

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendResponseDataMasking{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiDiagnosticSpecFrontendResponseDataMasking)(ptr) = objs[0]
			} else {
				*(*ApiDiagnosticSpecFrontendResponseDataMasking)(ptr) = ApiDiagnosticSpecFrontendResponseDataMasking{}
			}
		} else {
			*(*ApiDiagnosticSpecFrontendResponseDataMasking)(ptr) = ApiDiagnosticSpecFrontendResponseDataMasking{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiDiagnosticSpecFrontendResponseDataMasking

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendResponseDataMasking{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiDiagnosticSpecFrontendResponseDataMasking)(ptr) = obj
		} else {
			*(*ApiDiagnosticSpecFrontendResponseDataMasking)(ptr) = ApiDiagnosticSpecFrontendResponseDataMasking{}
		}
	default:
		iter.ReportError("decode ApiDiagnosticSpecFrontendResponseDataMasking", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiOperationSpecRequestCodec struct {
}

func (ApiOperationSpecRequestCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiOperationSpecRequest)(ptr) == nil
}

func (ApiOperationSpecRequestCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiOperationSpecRequest)(ptr)
	var objs []ApiOperationSpecRequest
	if obj != nil {
		objs = []ApiOperationSpecRequest{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiOperationSpecRequest{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiOperationSpecRequestCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiOperationSpecRequest)(ptr) = ApiOperationSpecRequest{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiOperationSpecRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiOperationSpecRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiOperationSpecRequest)(ptr) = objs[0]
			} else {
				*(*ApiOperationSpecRequest)(ptr) = ApiOperationSpecRequest{}
			}
		} else {
			*(*ApiOperationSpecRequest)(ptr) = ApiOperationSpecRequest{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApiOperationSpecRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiOperationSpecRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApiOperationSpecRequest)(ptr) = obj
		} else {
			*(*ApiOperationSpecRequest)(ptr) = ApiOperationSpecRequest{}
		}
	default:
		iter.ReportError("decode ApiOperationSpecRequest", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendSpecCredentialsCodec struct {
}

func (BackendSpecCredentialsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendSpecCredentials)(ptr) == nil
}

func (BackendSpecCredentialsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendSpecCredentials)(ptr)
	var objs []BackendSpecCredentials
	if obj != nil {
		objs = []BackendSpecCredentials{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecCredentials{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendSpecCredentialsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendSpecCredentials)(ptr) = BackendSpecCredentials{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendSpecCredentials

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecCredentials{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendSpecCredentials)(ptr) = objs[0]
			} else {
				*(*BackendSpecCredentials)(ptr) = BackendSpecCredentials{}
			}
		} else {
			*(*BackendSpecCredentials)(ptr) = BackendSpecCredentials{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackendSpecCredentials

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecCredentials{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackendSpecCredentials)(ptr) = obj
		} else {
			*(*BackendSpecCredentials)(ptr) = BackendSpecCredentials{}
		}
	default:
		iter.ReportError("decode BackendSpecCredentials", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendSpecCredentialsAuthorizationCodec struct {
}

func (BackendSpecCredentialsAuthorizationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendSpecCredentialsAuthorization)(ptr) == nil
}

func (BackendSpecCredentialsAuthorizationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendSpecCredentialsAuthorization)(ptr)
	var objs []BackendSpecCredentialsAuthorization
	if obj != nil {
		objs = []BackendSpecCredentialsAuthorization{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecCredentialsAuthorization{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendSpecCredentialsAuthorizationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendSpecCredentialsAuthorization)(ptr) = BackendSpecCredentialsAuthorization{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendSpecCredentialsAuthorization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecCredentialsAuthorization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendSpecCredentialsAuthorization)(ptr) = objs[0]
			} else {
				*(*BackendSpecCredentialsAuthorization)(ptr) = BackendSpecCredentialsAuthorization{}
			}
		} else {
			*(*BackendSpecCredentialsAuthorization)(ptr) = BackendSpecCredentialsAuthorization{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackendSpecCredentialsAuthorization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecCredentialsAuthorization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackendSpecCredentialsAuthorization)(ptr) = obj
		} else {
			*(*BackendSpecCredentialsAuthorization)(ptr) = BackendSpecCredentialsAuthorization{}
		}
	default:
		iter.ReportError("decode BackendSpecCredentialsAuthorization", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendSpecProxyCodec struct {
}

func (BackendSpecProxyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendSpecProxy)(ptr) == nil
}

func (BackendSpecProxyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendSpecProxy)(ptr)
	var objs []BackendSpecProxy
	if obj != nil {
		objs = []BackendSpecProxy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecProxy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendSpecProxyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendSpecProxy)(ptr) = BackendSpecProxy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendSpecProxy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecProxy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendSpecProxy)(ptr) = objs[0]
			} else {
				*(*BackendSpecProxy)(ptr) = BackendSpecProxy{}
			}
		} else {
			*(*BackendSpecProxy)(ptr) = BackendSpecProxy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackendSpecProxy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecProxy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackendSpecProxy)(ptr) = obj
		} else {
			*(*BackendSpecProxy)(ptr) = BackendSpecProxy{}
		}
	default:
		iter.ReportError("decode BackendSpecProxy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendSpecServiceFabricClusterCodec struct {
}

func (BackendSpecServiceFabricClusterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendSpecServiceFabricCluster)(ptr) == nil
}

func (BackendSpecServiceFabricClusterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendSpecServiceFabricCluster)(ptr)
	var objs []BackendSpecServiceFabricCluster
	if obj != nil {
		objs = []BackendSpecServiceFabricCluster{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecServiceFabricCluster{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendSpecServiceFabricClusterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendSpecServiceFabricCluster)(ptr) = BackendSpecServiceFabricCluster{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendSpecServiceFabricCluster

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecServiceFabricCluster{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendSpecServiceFabricCluster)(ptr) = objs[0]
			} else {
				*(*BackendSpecServiceFabricCluster)(ptr) = BackendSpecServiceFabricCluster{}
			}
		} else {
			*(*BackendSpecServiceFabricCluster)(ptr) = BackendSpecServiceFabricCluster{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackendSpecServiceFabricCluster

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecServiceFabricCluster{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackendSpecServiceFabricCluster)(ptr) = obj
		} else {
			*(*BackendSpecServiceFabricCluster)(ptr) = BackendSpecServiceFabricCluster{}
		}
	default:
		iter.ReportError("decode BackendSpecServiceFabricCluster", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendSpecTlsCodec struct {
}

func (BackendSpecTlsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendSpecTls)(ptr) == nil
}

func (BackendSpecTlsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendSpecTls)(ptr)
	var objs []BackendSpecTls
	if obj != nil {
		objs = []BackendSpecTls{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecTls{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendSpecTlsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendSpecTls)(ptr) = BackendSpecTls{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendSpecTls

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecTls{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendSpecTls)(ptr) = objs[0]
			} else {
				*(*BackendSpecTls)(ptr) = BackendSpecTls{}
			}
		} else {
			*(*BackendSpecTls)(ptr) = BackendSpecTls{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj BackendSpecTls

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecTls{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*BackendSpecTls)(ptr) = obj
		} else {
			*(*BackendSpecTls)(ptr) = BackendSpecTls{}
		}
	default:
		iter.ReportError("decode BackendSpecTls", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiagnosticSpecBackendRequestCodec struct {
}

func (DiagnosticSpecBackendRequestCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiagnosticSpecBackendRequest)(ptr) == nil
}

func (DiagnosticSpecBackendRequestCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiagnosticSpecBackendRequest)(ptr)
	var objs []DiagnosticSpecBackendRequest
	if obj != nil {
		objs = []DiagnosticSpecBackendRequest{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendRequest{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiagnosticSpecBackendRequestCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiagnosticSpecBackendRequest)(ptr) = DiagnosticSpecBackendRequest{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiagnosticSpecBackendRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiagnosticSpecBackendRequest)(ptr) = objs[0]
			} else {
				*(*DiagnosticSpecBackendRequest)(ptr) = DiagnosticSpecBackendRequest{}
			}
		} else {
			*(*DiagnosticSpecBackendRequest)(ptr) = DiagnosticSpecBackendRequest{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DiagnosticSpecBackendRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DiagnosticSpecBackendRequest)(ptr) = obj
		} else {
			*(*DiagnosticSpecBackendRequest)(ptr) = DiagnosticSpecBackendRequest{}
		}
	default:
		iter.ReportError("decode DiagnosticSpecBackendRequest", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiagnosticSpecBackendRequestDataMaskingCodec struct {
}

func (DiagnosticSpecBackendRequestDataMaskingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiagnosticSpecBackendRequestDataMasking)(ptr) == nil
}

func (DiagnosticSpecBackendRequestDataMaskingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiagnosticSpecBackendRequestDataMasking)(ptr)
	var objs []DiagnosticSpecBackendRequestDataMasking
	if obj != nil {
		objs = []DiagnosticSpecBackendRequestDataMasking{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendRequestDataMasking{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiagnosticSpecBackendRequestDataMaskingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiagnosticSpecBackendRequestDataMasking)(ptr) = DiagnosticSpecBackendRequestDataMasking{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiagnosticSpecBackendRequestDataMasking

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendRequestDataMasking{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiagnosticSpecBackendRequestDataMasking)(ptr) = objs[0]
			} else {
				*(*DiagnosticSpecBackendRequestDataMasking)(ptr) = DiagnosticSpecBackendRequestDataMasking{}
			}
		} else {
			*(*DiagnosticSpecBackendRequestDataMasking)(ptr) = DiagnosticSpecBackendRequestDataMasking{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DiagnosticSpecBackendRequestDataMasking

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendRequestDataMasking{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DiagnosticSpecBackendRequestDataMasking)(ptr) = obj
		} else {
			*(*DiagnosticSpecBackendRequestDataMasking)(ptr) = DiagnosticSpecBackendRequestDataMasking{}
		}
	default:
		iter.ReportError("decode DiagnosticSpecBackendRequestDataMasking", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiagnosticSpecBackendResponseCodec struct {
}

func (DiagnosticSpecBackendResponseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiagnosticSpecBackendResponse)(ptr) == nil
}

func (DiagnosticSpecBackendResponseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiagnosticSpecBackendResponse)(ptr)
	var objs []DiagnosticSpecBackendResponse
	if obj != nil {
		objs = []DiagnosticSpecBackendResponse{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendResponse{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiagnosticSpecBackendResponseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiagnosticSpecBackendResponse)(ptr) = DiagnosticSpecBackendResponse{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiagnosticSpecBackendResponse

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendResponse{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiagnosticSpecBackendResponse)(ptr) = objs[0]
			} else {
				*(*DiagnosticSpecBackendResponse)(ptr) = DiagnosticSpecBackendResponse{}
			}
		} else {
			*(*DiagnosticSpecBackendResponse)(ptr) = DiagnosticSpecBackendResponse{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DiagnosticSpecBackendResponse

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendResponse{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DiagnosticSpecBackendResponse)(ptr) = obj
		} else {
			*(*DiagnosticSpecBackendResponse)(ptr) = DiagnosticSpecBackendResponse{}
		}
	default:
		iter.ReportError("decode DiagnosticSpecBackendResponse", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiagnosticSpecBackendResponseDataMaskingCodec struct {
}

func (DiagnosticSpecBackendResponseDataMaskingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiagnosticSpecBackendResponseDataMasking)(ptr) == nil
}

func (DiagnosticSpecBackendResponseDataMaskingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiagnosticSpecBackendResponseDataMasking)(ptr)
	var objs []DiagnosticSpecBackendResponseDataMasking
	if obj != nil {
		objs = []DiagnosticSpecBackendResponseDataMasking{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendResponseDataMasking{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiagnosticSpecBackendResponseDataMaskingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiagnosticSpecBackendResponseDataMasking)(ptr) = DiagnosticSpecBackendResponseDataMasking{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiagnosticSpecBackendResponseDataMasking

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendResponseDataMasking{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiagnosticSpecBackendResponseDataMasking)(ptr) = objs[0]
			} else {
				*(*DiagnosticSpecBackendResponseDataMasking)(ptr) = DiagnosticSpecBackendResponseDataMasking{}
			}
		} else {
			*(*DiagnosticSpecBackendResponseDataMasking)(ptr) = DiagnosticSpecBackendResponseDataMasking{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DiagnosticSpecBackendResponseDataMasking

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendResponseDataMasking{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DiagnosticSpecBackendResponseDataMasking)(ptr) = obj
		} else {
			*(*DiagnosticSpecBackendResponseDataMasking)(ptr) = DiagnosticSpecBackendResponseDataMasking{}
		}
	default:
		iter.ReportError("decode DiagnosticSpecBackendResponseDataMasking", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiagnosticSpecFrontendRequestCodec struct {
}

func (DiagnosticSpecFrontendRequestCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiagnosticSpecFrontendRequest)(ptr) == nil
}

func (DiagnosticSpecFrontendRequestCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiagnosticSpecFrontendRequest)(ptr)
	var objs []DiagnosticSpecFrontendRequest
	if obj != nil {
		objs = []DiagnosticSpecFrontendRequest{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendRequest{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiagnosticSpecFrontendRequestCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiagnosticSpecFrontendRequest)(ptr) = DiagnosticSpecFrontendRequest{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiagnosticSpecFrontendRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiagnosticSpecFrontendRequest)(ptr) = objs[0]
			} else {
				*(*DiagnosticSpecFrontendRequest)(ptr) = DiagnosticSpecFrontendRequest{}
			}
		} else {
			*(*DiagnosticSpecFrontendRequest)(ptr) = DiagnosticSpecFrontendRequest{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DiagnosticSpecFrontendRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DiagnosticSpecFrontendRequest)(ptr) = obj
		} else {
			*(*DiagnosticSpecFrontendRequest)(ptr) = DiagnosticSpecFrontendRequest{}
		}
	default:
		iter.ReportError("decode DiagnosticSpecFrontendRequest", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiagnosticSpecFrontendRequestDataMaskingCodec struct {
}

func (DiagnosticSpecFrontendRequestDataMaskingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiagnosticSpecFrontendRequestDataMasking)(ptr) == nil
}

func (DiagnosticSpecFrontendRequestDataMaskingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiagnosticSpecFrontendRequestDataMasking)(ptr)
	var objs []DiagnosticSpecFrontendRequestDataMasking
	if obj != nil {
		objs = []DiagnosticSpecFrontendRequestDataMasking{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendRequestDataMasking{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiagnosticSpecFrontendRequestDataMaskingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiagnosticSpecFrontendRequestDataMasking)(ptr) = DiagnosticSpecFrontendRequestDataMasking{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiagnosticSpecFrontendRequestDataMasking

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendRequestDataMasking{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiagnosticSpecFrontendRequestDataMasking)(ptr) = objs[0]
			} else {
				*(*DiagnosticSpecFrontendRequestDataMasking)(ptr) = DiagnosticSpecFrontendRequestDataMasking{}
			}
		} else {
			*(*DiagnosticSpecFrontendRequestDataMasking)(ptr) = DiagnosticSpecFrontendRequestDataMasking{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DiagnosticSpecFrontendRequestDataMasking

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendRequestDataMasking{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DiagnosticSpecFrontendRequestDataMasking)(ptr) = obj
		} else {
			*(*DiagnosticSpecFrontendRequestDataMasking)(ptr) = DiagnosticSpecFrontendRequestDataMasking{}
		}
	default:
		iter.ReportError("decode DiagnosticSpecFrontendRequestDataMasking", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiagnosticSpecFrontendResponseCodec struct {
}

func (DiagnosticSpecFrontendResponseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiagnosticSpecFrontendResponse)(ptr) == nil
}

func (DiagnosticSpecFrontendResponseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiagnosticSpecFrontendResponse)(ptr)
	var objs []DiagnosticSpecFrontendResponse
	if obj != nil {
		objs = []DiagnosticSpecFrontendResponse{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendResponse{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiagnosticSpecFrontendResponseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiagnosticSpecFrontendResponse)(ptr) = DiagnosticSpecFrontendResponse{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiagnosticSpecFrontendResponse

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendResponse{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiagnosticSpecFrontendResponse)(ptr) = objs[0]
			} else {
				*(*DiagnosticSpecFrontendResponse)(ptr) = DiagnosticSpecFrontendResponse{}
			}
		} else {
			*(*DiagnosticSpecFrontendResponse)(ptr) = DiagnosticSpecFrontendResponse{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DiagnosticSpecFrontendResponse

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendResponse{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DiagnosticSpecFrontendResponse)(ptr) = obj
		} else {
			*(*DiagnosticSpecFrontendResponse)(ptr) = DiagnosticSpecFrontendResponse{}
		}
	default:
		iter.ReportError("decode DiagnosticSpecFrontendResponse", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiagnosticSpecFrontendResponseDataMaskingCodec struct {
}

func (DiagnosticSpecFrontendResponseDataMaskingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiagnosticSpecFrontendResponseDataMasking)(ptr) == nil
}

func (DiagnosticSpecFrontendResponseDataMaskingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiagnosticSpecFrontendResponseDataMasking)(ptr)
	var objs []DiagnosticSpecFrontendResponseDataMasking
	if obj != nil {
		objs = []DiagnosticSpecFrontendResponseDataMasking{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendResponseDataMasking{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiagnosticSpecFrontendResponseDataMaskingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiagnosticSpecFrontendResponseDataMasking)(ptr) = DiagnosticSpecFrontendResponseDataMasking{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiagnosticSpecFrontendResponseDataMasking

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendResponseDataMasking{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiagnosticSpecFrontendResponseDataMasking)(ptr) = objs[0]
			} else {
				*(*DiagnosticSpecFrontendResponseDataMasking)(ptr) = DiagnosticSpecFrontendResponseDataMasking{}
			}
		} else {
			*(*DiagnosticSpecFrontendResponseDataMasking)(ptr) = DiagnosticSpecFrontendResponseDataMasking{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DiagnosticSpecFrontendResponseDataMasking

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendResponseDataMasking{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DiagnosticSpecFrontendResponseDataMasking)(ptr) = obj
		} else {
			*(*DiagnosticSpecFrontendResponseDataMasking)(ptr) = DiagnosticSpecFrontendResponseDataMasking{}
		}
	default:
		iter.ReportError("decode DiagnosticSpecFrontendResponseDataMasking", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GatewaySpecLocationDataCodec struct {
}

func (GatewaySpecLocationDataCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GatewaySpecLocationData)(ptr) == nil
}

func (GatewaySpecLocationDataCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GatewaySpecLocationData)(ptr)
	var objs []GatewaySpecLocationData
	if obj != nil {
		objs = []GatewaySpecLocationData{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewaySpecLocationData{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GatewaySpecLocationDataCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GatewaySpecLocationData)(ptr) = GatewaySpecLocationData{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GatewaySpecLocationData

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewaySpecLocationData{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GatewaySpecLocationData)(ptr) = objs[0]
			} else {
				*(*GatewaySpecLocationData)(ptr) = GatewaySpecLocationData{}
			}
		} else {
			*(*GatewaySpecLocationData)(ptr) = GatewaySpecLocationData{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj GatewaySpecLocationData

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewaySpecLocationData{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*GatewaySpecLocationData)(ptr) = obj
		} else {
			*(*GatewaySpecLocationData)(ptr) = GatewaySpecLocationData{}
		}
	default:
		iter.ReportError("decode GatewaySpecLocationData", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LoggerSpecApplicationInsightsCodec struct {
}

func (LoggerSpecApplicationInsightsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LoggerSpecApplicationInsights)(ptr) == nil
}

func (LoggerSpecApplicationInsightsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LoggerSpecApplicationInsights)(ptr)
	var objs []LoggerSpecApplicationInsights
	if obj != nil {
		objs = []LoggerSpecApplicationInsights{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoggerSpecApplicationInsights{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LoggerSpecApplicationInsightsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LoggerSpecApplicationInsights)(ptr) = LoggerSpecApplicationInsights{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LoggerSpecApplicationInsights

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoggerSpecApplicationInsights{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LoggerSpecApplicationInsights)(ptr) = objs[0]
			} else {
				*(*LoggerSpecApplicationInsights)(ptr) = LoggerSpecApplicationInsights{}
			}
		} else {
			*(*LoggerSpecApplicationInsights)(ptr) = LoggerSpecApplicationInsights{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj LoggerSpecApplicationInsights

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoggerSpecApplicationInsights{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*LoggerSpecApplicationInsights)(ptr) = obj
		} else {
			*(*LoggerSpecApplicationInsights)(ptr) = LoggerSpecApplicationInsights{}
		}
	default:
		iter.ReportError("decode LoggerSpecApplicationInsights", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LoggerSpecEventhubCodec struct {
}

func (LoggerSpecEventhubCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LoggerSpecEventhub)(ptr) == nil
}

func (LoggerSpecEventhubCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LoggerSpecEventhub)(ptr)
	var objs []LoggerSpecEventhub
	if obj != nil {
		objs = []LoggerSpecEventhub{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoggerSpecEventhub{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LoggerSpecEventhubCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LoggerSpecEventhub)(ptr) = LoggerSpecEventhub{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LoggerSpecEventhub

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoggerSpecEventhub{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LoggerSpecEventhub)(ptr) = objs[0]
			} else {
				*(*LoggerSpecEventhub)(ptr) = LoggerSpecEventhub{}
			}
		} else {
			*(*LoggerSpecEventhub)(ptr) = LoggerSpecEventhub{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj LoggerSpecEventhub

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoggerSpecEventhub{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*LoggerSpecEventhub)(ptr) = obj
		} else {
			*(*LoggerSpecEventhub)(ptr) = LoggerSpecEventhub{}
		}
	default:
		iter.ReportError("decode LoggerSpecEventhub", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamedValueSpecValueFromKeyVaultCodec struct {
}

func (NamedValueSpecValueFromKeyVaultCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamedValueSpecValueFromKeyVault)(ptr) == nil
}

func (NamedValueSpecValueFromKeyVaultCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamedValueSpecValueFromKeyVault)(ptr)
	var objs []NamedValueSpecValueFromKeyVault
	if obj != nil {
		objs = []NamedValueSpecValueFromKeyVault{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamedValueSpecValueFromKeyVault{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamedValueSpecValueFromKeyVaultCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamedValueSpecValueFromKeyVault)(ptr) = NamedValueSpecValueFromKeyVault{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamedValueSpecValueFromKeyVault

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamedValueSpecValueFromKeyVault{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamedValueSpecValueFromKeyVault)(ptr) = objs[0]
			} else {
				*(*NamedValueSpecValueFromKeyVault)(ptr) = NamedValueSpecValueFromKeyVault{}
			}
		} else {
			*(*NamedValueSpecValueFromKeyVault)(ptr) = NamedValueSpecValueFromKeyVault{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamedValueSpecValueFromKeyVault

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamedValueSpecValueFromKeyVault{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamedValueSpecValueFromKeyVault)(ptr) = obj
		} else {
			*(*NamedValueSpecValueFromKeyVault)(ptr) = NamedValueSpecValueFromKeyVault{}
		}
	default:
		iter.ReportError("decode NamedValueSpecValueFromKeyVault", "unexpected JSON type")
	}
}

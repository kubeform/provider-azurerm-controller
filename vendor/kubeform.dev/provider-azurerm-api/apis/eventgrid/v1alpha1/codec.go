/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecIdentity{}).Type1()):                                               DomainSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecInputMappingDefaultValues{}).Type1()):                              DomainSpecInputMappingDefaultValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecInputMappingFields{}).Type1()):                                     DomainSpecInputMappingFieldsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecAdvancedFilter{}).Type1()):                              EventSubscriptionSpecAdvancedFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecAzureFunctionEndpoint{}).Type1()):                       EventSubscriptionSpecAzureFunctionEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecDeadLetterIdentity{}).Type1()):                          EventSubscriptionSpecDeadLetterIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecDeliveryIdentity{}).Type1()):                            EventSubscriptionSpecDeliveryIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecEventhubEndpoint{}).Type1()):                            EventSubscriptionSpecEventhubEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecHybridConnectionEndpoint{}).Type1()):                    EventSubscriptionSpecHybridConnectionEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecRetryPolicy{}).Type1()):                                 EventSubscriptionSpecRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecStorageBlobDeadLetterDestination{}).Type1()):            EventSubscriptionSpecStorageBlobDeadLetterDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecStorageQueueEndpoint{}).Type1()):                        EventSubscriptionSpecStorageQueueEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecSubjectFilter{}).Type1()):                               EventSubscriptionSpecSubjectFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecWebhookEndpoint{}).Type1()):                             EventSubscriptionSpecWebhookEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicSpecIdentity{}).Type1()):                                          SystemTopicSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecAdvancedFilter{}).Type1()):                   SystemTopicEventSubscriptionSpecAdvancedFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecAzureFunctionEndpoint{}).Type1()):            SystemTopicEventSubscriptionSpecAzureFunctionEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecDeadLetterIdentity{}).Type1()):               SystemTopicEventSubscriptionSpecDeadLetterIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecDeliveryIdentity{}).Type1()):                 SystemTopicEventSubscriptionSpecDeliveryIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecRetryPolicy{}).Type1()):                      SystemTopicEventSubscriptionSpecRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination{}).Type1()): SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecStorageQueueEndpoint{}).Type1()):             SystemTopicEventSubscriptionSpecStorageQueueEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecSubjectFilter{}).Type1()):                    SystemTopicEventSubscriptionSpecSubjectFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecWebhookEndpoint{}).Type1()):                  SystemTopicEventSubscriptionSpecWebhookEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecIdentity{}).Type1()):                                                TopicSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecInputMappingDefaultValues{}).Type1()):                               TopicSpecInputMappingDefaultValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecInputMappingFields{}).Type1()):                                      TopicSpecInputMappingFieldsCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecIdentity{}).Type1()):                                               DomainSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecInputMappingDefaultValues{}).Type1()):                              DomainSpecInputMappingDefaultValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecInputMappingFields{}).Type1()):                                     DomainSpecInputMappingFieldsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecAdvancedFilter{}).Type1()):                              EventSubscriptionSpecAdvancedFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecAzureFunctionEndpoint{}).Type1()):                       EventSubscriptionSpecAzureFunctionEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecDeadLetterIdentity{}).Type1()):                          EventSubscriptionSpecDeadLetterIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecDeliveryIdentity{}).Type1()):                            EventSubscriptionSpecDeliveryIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecEventhubEndpoint{}).Type1()):                            EventSubscriptionSpecEventhubEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecHybridConnectionEndpoint{}).Type1()):                    EventSubscriptionSpecHybridConnectionEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecRetryPolicy{}).Type1()):                                 EventSubscriptionSpecRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecStorageBlobDeadLetterDestination{}).Type1()):            EventSubscriptionSpecStorageBlobDeadLetterDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecStorageQueueEndpoint{}).Type1()):                        EventSubscriptionSpecStorageQueueEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecSubjectFilter{}).Type1()):                               EventSubscriptionSpecSubjectFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecWebhookEndpoint{}).Type1()):                             EventSubscriptionSpecWebhookEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicSpecIdentity{}).Type1()):                                          SystemTopicSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecAdvancedFilter{}).Type1()):                   SystemTopicEventSubscriptionSpecAdvancedFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecAzureFunctionEndpoint{}).Type1()):            SystemTopicEventSubscriptionSpecAzureFunctionEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecDeadLetterIdentity{}).Type1()):               SystemTopicEventSubscriptionSpecDeadLetterIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecDeliveryIdentity{}).Type1()):                 SystemTopicEventSubscriptionSpecDeliveryIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecRetryPolicy{}).Type1()):                      SystemTopicEventSubscriptionSpecRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination{}).Type1()): SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecStorageQueueEndpoint{}).Type1()):             SystemTopicEventSubscriptionSpecStorageQueueEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecSubjectFilter{}).Type1()):                    SystemTopicEventSubscriptionSpecSubjectFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecWebhookEndpoint{}).Type1()):                  SystemTopicEventSubscriptionSpecWebhookEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecIdentity{}).Type1()):                                                TopicSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecInputMappingDefaultValues{}).Type1()):                               TopicSpecInputMappingDefaultValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecInputMappingFields{}).Type1()):                                      TopicSpecInputMappingFieldsCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type DomainSpecIdentityCodec struct {
}

func (DomainSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DomainSpecIdentity)(ptr) == nil
}

func (DomainSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DomainSpecIdentity)(ptr)
	var objs []DomainSpecIdentity
	if obj != nil {
		objs = []DomainSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DomainSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DomainSpecIdentity)(ptr) = DomainSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DomainSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DomainSpecIdentity)(ptr) = objs[0]
			} else {
				*(*DomainSpecIdentity)(ptr) = DomainSpecIdentity{}
			}
		} else {
			*(*DomainSpecIdentity)(ptr) = DomainSpecIdentity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DomainSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DomainSpecIdentity)(ptr) = obj
		} else {
			*(*DomainSpecIdentity)(ptr) = DomainSpecIdentity{}
		}
	default:
		iter.ReportError("decode DomainSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DomainSpecInputMappingDefaultValuesCodec struct {
}

func (DomainSpecInputMappingDefaultValuesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DomainSpecInputMappingDefaultValues)(ptr) == nil
}

func (DomainSpecInputMappingDefaultValuesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DomainSpecInputMappingDefaultValues)(ptr)
	var objs []DomainSpecInputMappingDefaultValues
	if obj != nil {
		objs = []DomainSpecInputMappingDefaultValues{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecInputMappingDefaultValues{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DomainSpecInputMappingDefaultValuesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DomainSpecInputMappingDefaultValues)(ptr) = DomainSpecInputMappingDefaultValues{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DomainSpecInputMappingDefaultValues

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecInputMappingDefaultValues{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DomainSpecInputMappingDefaultValues)(ptr) = objs[0]
			} else {
				*(*DomainSpecInputMappingDefaultValues)(ptr) = DomainSpecInputMappingDefaultValues{}
			}
		} else {
			*(*DomainSpecInputMappingDefaultValues)(ptr) = DomainSpecInputMappingDefaultValues{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DomainSpecInputMappingDefaultValues

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecInputMappingDefaultValues{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DomainSpecInputMappingDefaultValues)(ptr) = obj
		} else {
			*(*DomainSpecInputMappingDefaultValues)(ptr) = DomainSpecInputMappingDefaultValues{}
		}
	default:
		iter.ReportError("decode DomainSpecInputMappingDefaultValues", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DomainSpecInputMappingFieldsCodec struct {
}

func (DomainSpecInputMappingFieldsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DomainSpecInputMappingFields)(ptr) == nil
}

func (DomainSpecInputMappingFieldsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DomainSpecInputMappingFields)(ptr)
	var objs []DomainSpecInputMappingFields
	if obj != nil {
		objs = []DomainSpecInputMappingFields{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecInputMappingFields{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DomainSpecInputMappingFieldsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DomainSpecInputMappingFields)(ptr) = DomainSpecInputMappingFields{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DomainSpecInputMappingFields

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecInputMappingFields{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DomainSpecInputMappingFields)(ptr) = objs[0]
			} else {
				*(*DomainSpecInputMappingFields)(ptr) = DomainSpecInputMappingFields{}
			}
		} else {
			*(*DomainSpecInputMappingFields)(ptr) = DomainSpecInputMappingFields{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DomainSpecInputMappingFields

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecInputMappingFields{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DomainSpecInputMappingFields)(ptr) = obj
		} else {
			*(*DomainSpecInputMappingFields)(ptr) = DomainSpecInputMappingFields{}
		}
	default:
		iter.ReportError("decode DomainSpecInputMappingFields", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSubscriptionSpecAdvancedFilterCodec struct {
}

func (EventSubscriptionSpecAdvancedFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSubscriptionSpecAdvancedFilter)(ptr) == nil
}

func (EventSubscriptionSpecAdvancedFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSubscriptionSpecAdvancedFilter)(ptr)
	var objs []EventSubscriptionSpecAdvancedFilter
	if obj != nil {
		objs = []EventSubscriptionSpecAdvancedFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecAdvancedFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSubscriptionSpecAdvancedFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSubscriptionSpecAdvancedFilter)(ptr) = EventSubscriptionSpecAdvancedFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSubscriptionSpecAdvancedFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecAdvancedFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSubscriptionSpecAdvancedFilter)(ptr) = objs[0]
			} else {
				*(*EventSubscriptionSpecAdvancedFilter)(ptr) = EventSubscriptionSpecAdvancedFilter{}
			}
		} else {
			*(*EventSubscriptionSpecAdvancedFilter)(ptr) = EventSubscriptionSpecAdvancedFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventSubscriptionSpecAdvancedFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecAdvancedFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventSubscriptionSpecAdvancedFilter)(ptr) = obj
		} else {
			*(*EventSubscriptionSpecAdvancedFilter)(ptr) = EventSubscriptionSpecAdvancedFilter{}
		}
	default:
		iter.ReportError("decode EventSubscriptionSpecAdvancedFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSubscriptionSpecAzureFunctionEndpointCodec struct {
}

func (EventSubscriptionSpecAzureFunctionEndpointCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSubscriptionSpecAzureFunctionEndpoint)(ptr) == nil
}

func (EventSubscriptionSpecAzureFunctionEndpointCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSubscriptionSpecAzureFunctionEndpoint)(ptr)
	var objs []EventSubscriptionSpecAzureFunctionEndpoint
	if obj != nil {
		objs = []EventSubscriptionSpecAzureFunctionEndpoint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecAzureFunctionEndpoint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSubscriptionSpecAzureFunctionEndpointCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSubscriptionSpecAzureFunctionEndpoint)(ptr) = EventSubscriptionSpecAzureFunctionEndpoint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSubscriptionSpecAzureFunctionEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecAzureFunctionEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSubscriptionSpecAzureFunctionEndpoint)(ptr) = objs[0]
			} else {
				*(*EventSubscriptionSpecAzureFunctionEndpoint)(ptr) = EventSubscriptionSpecAzureFunctionEndpoint{}
			}
		} else {
			*(*EventSubscriptionSpecAzureFunctionEndpoint)(ptr) = EventSubscriptionSpecAzureFunctionEndpoint{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventSubscriptionSpecAzureFunctionEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecAzureFunctionEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventSubscriptionSpecAzureFunctionEndpoint)(ptr) = obj
		} else {
			*(*EventSubscriptionSpecAzureFunctionEndpoint)(ptr) = EventSubscriptionSpecAzureFunctionEndpoint{}
		}
	default:
		iter.ReportError("decode EventSubscriptionSpecAzureFunctionEndpoint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSubscriptionSpecDeadLetterIdentityCodec struct {
}

func (EventSubscriptionSpecDeadLetterIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSubscriptionSpecDeadLetterIdentity)(ptr) == nil
}

func (EventSubscriptionSpecDeadLetterIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSubscriptionSpecDeadLetterIdentity)(ptr)
	var objs []EventSubscriptionSpecDeadLetterIdentity
	if obj != nil {
		objs = []EventSubscriptionSpecDeadLetterIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecDeadLetterIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSubscriptionSpecDeadLetterIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSubscriptionSpecDeadLetterIdentity)(ptr) = EventSubscriptionSpecDeadLetterIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSubscriptionSpecDeadLetterIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecDeadLetterIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSubscriptionSpecDeadLetterIdentity)(ptr) = objs[0]
			} else {
				*(*EventSubscriptionSpecDeadLetterIdentity)(ptr) = EventSubscriptionSpecDeadLetterIdentity{}
			}
		} else {
			*(*EventSubscriptionSpecDeadLetterIdentity)(ptr) = EventSubscriptionSpecDeadLetterIdentity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventSubscriptionSpecDeadLetterIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecDeadLetterIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventSubscriptionSpecDeadLetterIdentity)(ptr) = obj
		} else {
			*(*EventSubscriptionSpecDeadLetterIdentity)(ptr) = EventSubscriptionSpecDeadLetterIdentity{}
		}
	default:
		iter.ReportError("decode EventSubscriptionSpecDeadLetterIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSubscriptionSpecDeliveryIdentityCodec struct {
}

func (EventSubscriptionSpecDeliveryIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSubscriptionSpecDeliveryIdentity)(ptr) == nil
}

func (EventSubscriptionSpecDeliveryIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSubscriptionSpecDeliveryIdentity)(ptr)
	var objs []EventSubscriptionSpecDeliveryIdentity
	if obj != nil {
		objs = []EventSubscriptionSpecDeliveryIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecDeliveryIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSubscriptionSpecDeliveryIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSubscriptionSpecDeliveryIdentity)(ptr) = EventSubscriptionSpecDeliveryIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSubscriptionSpecDeliveryIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecDeliveryIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSubscriptionSpecDeliveryIdentity)(ptr) = objs[0]
			} else {
				*(*EventSubscriptionSpecDeliveryIdentity)(ptr) = EventSubscriptionSpecDeliveryIdentity{}
			}
		} else {
			*(*EventSubscriptionSpecDeliveryIdentity)(ptr) = EventSubscriptionSpecDeliveryIdentity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventSubscriptionSpecDeliveryIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecDeliveryIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventSubscriptionSpecDeliveryIdentity)(ptr) = obj
		} else {
			*(*EventSubscriptionSpecDeliveryIdentity)(ptr) = EventSubscriptionSpecDeliveryIdentity{}
		}
	default:
		iter.ReportError("decode EventSubscriptionSpecDeliveryIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSubscriptionSpecEventhubEndpointCodec struct {
}

func (EventSubscriptionSpecEventhubEndpointCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSubscriptionSpecEventhubEndpoint)(ptr) == nil
}

func (EventSubscriptionSpecEventhubEndpointCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSubscriptionSpecEventhubEndpoint)(ptr)
	var objs []EventSubscriptionSpecEventhubEndpoint
	if obj != nil {
		objs = []EventSubscriptionSpecEventhubEndpoint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecEventhubEndpoint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSubscriptionSpecEventhubEndpointCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSubscriptionSpecEventhubEndpoint)(ptr) = EventSubscriptionSpecEventhubEndpoint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSubscriptionSpecEventhubEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecEventhubEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSubscriptionSpecEventhubEndpoint)(ptr) = objs[0]
			} else {
				*(*EventSubscriptionSpecEventhubEndpoint)(ptr) = EventSubscriptionSpecEventhubEndpoint{}
			}
		} else {
			*(*EventSubscriptionSpecEventhubEndpoint)(ptr) = EventSubscriptionSpecEventhubEndpoint{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventSubscriptionSpecEventhubEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecEventhubEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventSubscriptionSpecEventhubEndpoint)(ptr) = obj
		} else {
			*(*EventSubscriptionSpecEventhubEndpoint)(ptr) = EventSubscriptionSpecEventhubEndpoint{}
		}
	default:
		iter.ReportError("decode EventSubscriptionSpecEventhubEndpoint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSubscriptionSpecHybridConnectionEndpointCodec struct {
}

func (EventSubscriptionSpecHybridConnectionEndpointCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSubscriptionSpecHybridConnectionEndpoint)(ptr) == nil
}

func (EventSubscriptionSpecHybridConnectionEndpointCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSubscriptionSpecHybridConnectionEndpoint)(ptr)
	var objs []EventSubscriptionSpecHybridConnectionEndpoint
	if obj != nil {
		objs = []EventSubscriptionSpecHybridConnectionEndpoint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecHybridConnectionEndpoint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSubscriptionSpecHybridConnectionEndpointCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSubscriptionSpecHybridConnectionEndpoint)(ptr) = EventSubscriptionSpecHybridConnectionEndpoint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSubscriptionSpecHybridConnectionEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecHybridConnectionEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSubscriptionSpecHybridConnectionEndpoint)(ptr) = objs[0]
			} else {
				*(*EventSubscriptionSpecHybridConnectionEndpoint)(ptr) = EventSubscriptionSpecHybridConnectionEndpoint{}
			}
		} else {
			*(*EventSubscriptionSpecHybridConnectionEndpoint)(ptr) = EventSubscriptionSpecHybridConnectionEndpoint{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventSubscriptionSpecHybridConnectionEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecHybridConnectionEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventSubscriptionSpecHybridConnectionEndpoint)(ptr) = obj
		} else {
			*(*EventSubscriptionSpecHybridConnectionEndpoint)(ptr) = EventSubscriptionSpecHybridConnectionEndpoint{}
		}
	default:
		iter.ReportError("decode EventSubscriptionSpecHybridConnectionEndpoint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSubscriptionSpecRetryPolicyCodec struct {
}

func (EventSubscriptionSpecRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSubscriptionSpecRetryPolicy)(ptr) == nil
}

func (EventSubscriptionSpecRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSubscriptionSpecRetryPolicy)(ptr)
	var objs []EventSubscriptionSpecRetryPolicy
	if obj != nil {
		objs = []EventSubscriptionSpecRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSubscriptionSpecRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSubscriptionSpecRetryPolicy)(ptr) = EventSubscriptionSpecRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSubscriptionSpecRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSubscriptionSpecRetryPolicy)(ptr) = objs[0]
			} else {
				*(*EventSubscriptionSpecRetryPolicy)(ptr) = EventSubscriptionSpecRetryPolicy{}
			}
		} else {
			*(*EventSubscriptionSpecRetryPolicy)(ptr) = EventSubscriptionSpecRetryPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventSubscriptionSpecRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventSubscriptionSpecRetryPolicy)(ptr) = obj
		} else {
			*(*EventSubscriptionSpecRetryPolicy)(ptr) = EventSubscriptionSpecRetryPolicy{}
		}
	default:
		iter.ReportError("decode EventSubscriptionSpecRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSubscriptionSpecStorageBlobDeadLetterDestinationCodec struct {
}

func (EventSubscriptionSpecStorageBlobDeadLetterDestinationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) == nil
}

func (EventSubscriptionSpecStorageBlobDeadLetterDestinationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr)
	var objs []EventSubscriptionSpecStorageBlobDeadLetterDestination
	if obj != nil {
		objs = []EventSubscriptionSpecStorageBlobDeadLetterDestination{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecStorageBlobDeadLetterDestination{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSubscriptionSpecStorageBlobDeadLetterDestinationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) = EventSubscriptionSpecStorageBlobDeadLetterDestination{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSubscriptionSpecStorageBlobDeadLetterDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecStorageBlobDeadLetterDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) = objs[0]
			} else {
				*(*EventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) = EventSubscriptionSpecStorageBlobDeadLetterDestination{}
			}
		} else {
			*(*EventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) = EventSubscriptionSpecStorageBlobDeadLetterDestination{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventSubscriptionSpecStorageBlobDeadLetterDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecStorageBlobDeadLetterDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) = obj
		} else {
			*(*EventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) = EventSubscriptionSpecStorageBlobDeadLetterDestination{}
		}
	default:
		iter.ReportError("decode EventSubscriptionSpecStorageBlobDeadLetterDestination", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSubscriptionSpecStorageQueueEndpointCodec struct {
}

func (EventSubscriptionSpecStorageQueueEndpointCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSubscriptionSpecStorageQueueEndpoint)(ptr) == nil
}

func (EventSubscriptionSpecStorageQueueEndpointCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSubscriptionSpecStorageQueueEndpoint)(ptr)
	var objs []EventSubscriptionSpecStorageQueueEndpoint
	if obj != nil {
		objs = []EventSubscriptionSpecStorageQueueEndpoint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecStorageQueueEndpoint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSubscriptionSpecStorageQueueEndpointCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSubscriptionSpecStorageQueueEndpoint)(ptr) = EventSubscriptionSpecStorageQueueEndpoint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSubscriptionSpecStorageQueueEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecStorageQueueEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSubscriptionSpecStorageQueueEndpoint)(ptr) = objs[0]
			} else {
				*(*EventSubscriptionSpecStorageQueueEndpoint)(ptr) = EventSubscriptionSpecStorageQueueEndpoint{}
			}
		} else {
			*(*EventSubscriptionSpecStorageQueueEndpoint)(ptr) = EventSubscriptionSpecStorageQueueEndpoint{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventSubscriptionSpecStorageQueueEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecStorageQueueEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventSubscriptionSpecStorageQueueEndpoint)(ptr) = obj
		} else {
			*(*EventSubscriptionSpecStorageQueueEndpoint)(ptr) = EventSubscriptionSpecStorageQueueEndpoint{}
		}
	default:
		iter.ReportError("decode EventSubscriptionSpecStorageQueueEndpoint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSubscriptionSpecSubjectFilterCodec struct {
}

func (EventSubscriptionSpecSubjectFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSubscriptionSpecSubjectFilter)(ptr) == nil
}

func (EventSubscriptionSpecSubjectFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSubscriptionSpecSubjectFilter)(ptr)
	var objs []EventSubscriptionSpecSubjectFilter
	if obj != nil {
		objs = []EventSubscriptionSpecSubjectFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecSubjectFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSubscriptionSpecSubjectFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSubscriptionSpecSubjectFilter)(ptr) = EventSubscriptionSpecSubjectFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSubscriptionSpecSubjectFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecSubjectFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSubscriptionSpecSubjectFilter)(ptr) = objs[0]
			} else {
				*(*EventSubscriptionSpecSubjectFilter)(ptr) = EventSubscriptionSpecSubjectFilter{}
			}
		} else {
			*(*EventSubscriptionSpecSubjectFilter)(ptr) = EventSubscriptionSpecSubjectFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventSubscriptionSpecSubjectFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecSubjectFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventSubscriptionSpecSubjectFilter)(ptr) = obj
		} else {
			*(*EventSubscriptionSpecSubjectFilter)(ptr) = EventSubscriptionSpecSubjectFilter{}
		}
	default:
		iter.ReportError("decode EventSubscriptionSpecSubjectFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSubscriptionSpecWebhookEndpointCodec struct {
}

func (EventSubscriptionSpecWebhookEndpointCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSubscriptionSpecWebhookEndpoint)(ptr) == nil
}

func (EventSubscriptionSpecWebhookEndpointCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSubscriptionSpecWebhookEndpoint)(ptr)
	var objs []EventSubscriptionSpecWebhookEndpoint
	if obj != nil {
		objs = []EventSubscriptionSpecWebhookEndpoint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecWebhookEndpoint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSubscriptionSpecWebhookEndpointCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSubscriptionSpecWebhookEndpoint)(ptr) = EventSubscriptionSpecWebhookEndpoint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSubscriptionSpecWebhookEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecWebhookEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSubscriptionSpecWebhookEndpoint)(ptr) = objs[0]
			} else {
				*(*EventSubscriptionSpecWebhookEndpoint)(ptr) = EventSubscriptionSpecWebhookEndpoint{}
			}
		} else {
			*(*EventSubscriptionSpecWebhookEndpoint)(ptr) = EventSubscriptionSpecWebhookEndpoint{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj EventSubscriptionSpecWebhookEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecWebhookEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*EventSubscriptionSpecWebhookEndpoint)(ptr) = obj
		} else {
			*(*EventSubscriptionSpecWebhookEndpoint)(ptr) = EventSubscriptionSpecWebhookEndpoint{}
		}
	default:
		iter.ReportError("decode EventSubscriptionSpecWebhookEndpoint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SystemTopicSpecIdentityCodec struct {
}

func (SystemTopicSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SystemTopicSpecIdentity)(ptr) == nil
}

func (SystemTopicSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SystemTopicSpecIdentity)(ptr)
	var objs []SystemTopicSpecIdentity
	if obj != nil {
		objs = []SystemTopicSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SystemTopicSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SystemTopicSpecIdentity)(ptr) = SystemTopicSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SystemTopicSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SystemTopicSpecIdentity)(ptr) = objs[0]
			} else {
				*(*SystemTopicSpecIdentity)(ptr) = SystemTopicSpecIdentity{}
			}
		} else {
			*(*SystemTopicSpecIdentity)(ptr) = SystemTopicSpecIdentity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SystemTopicSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SystemTopicSpecIdentity)(ptr) = obj
		} else {
			*(*SystemTopicSpecIdentity)(ptr) = SystemTopicSpecIdentity{}
		}
	default:
		iter.ReportError("decode SystemTopicSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SystemTopicEventSubscriptionSpecAdvancedFilterCodec struct {
}

func (SystemTopicEventSubscriptionSpecAdvancedFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SystemTopicEventSubscriptionSpecAdvancedFilter)(ptr) == nil
}

func (SystemTopicEventSubscriptionSpecAdvancedFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SystemTopicEventSubscriptionSpecAdvancedFilter)(ptr)
	var objs []SystemTopicEventSubscriptionSpecAdvancedFilter
	if obj != nil {
		objs = []SystemTopicEventSubscriptionSpecAdvancedFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecAdvancedFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SystemTopicEventSubscriptionSpecAdvancedFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SystemTopicEventSubscriptionSpecAdvancedFilter)(ptr) = SystemTopicEventSubscriptionSpecAdvancedFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SystemTopicEventSubscriptionSpecAdvancedFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecAdvancedFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SystemTopicEventSubscriptionSpecAdvancedFilter)(ptr) = objs[0]
			} else {
				*(*SystemTopicEventSubscriptionSpecAdvancedFilter)(ptr) = SystemTopicEventSubscriptionSpecAdvancedFilter{}
			}
		} else {
			*(*SystemTopicEventSubscriptionSpecAdvancedFilter)(ptr) = SystemTopicEventSubscriptionSpecAdvancedFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SystemTopicEventSubscriptionSpecAdvancedFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecAdvancedFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SystemTopicEventSubscriptionSpecAdvancedFilter)(ptr) = obj
		} else {
			*(*SystemTopicEventSubscriptionSpecAdvancedFilter)(ptr) = SystemTopicEventSubscriptionSpecAdvancedFilter{}
		}
	default:
		iter.ReportError("decode SystemTopicEventSubscriptionSpecAdvancedFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SystemTopicEventSubscriptionSpecAzureFunctionEndpointCodec struct {
}

func (SystemTopicEventSubscriptionSpecAzureFunctionEndpointCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SystemTopicEventSubscriptionSpecAzureFunctionEndpoint)(ptr) == nil
}

func (SystemTopicEventSubscriptionSpecAzureFunctionEndpointCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SystemTopicEventSubscriptionSpecAzureFunctionEndpoint)(ptr)
	var objs []SystemTopicEventSubscriptionSpecAzureFunctionEndpoint
	if obj != nil {
		objs = []SystemTopicEventSubscriptionSpecAzureFunctionEndpoint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecAzureFunctionEndpoint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SystemTopicEventSubscriptionSpecAzureFunctionEndpointCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SystemTopicEventSubscriptionSpecAzureFunctionEndpoint)(ptr) = SystemTopicEventSubscriptionSpecAzureFunctionEndpoint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SystemTopicEventSubscriptionSpecAzureFunctionEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecAzureFunctionEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SystemTopicEventSubscriptionSpecAzureFunctionEndpoint)(ptr) = objs[0]
			} else {
				*(*SystemTopicEventSubscriptionSpecAzureFunctionEndpoint)(ptr) = SystemTopicEventSubscriptionSpecAzureFunctionEndpoint{}
			}
		} else {
			*(*SystemTopicEventSubscriptionSpecAzureFunctionEndpoint)(ptr) = SystemTopicEventSubscriptionSpecAzureFunctionEndpoint{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SystemTopicEventSubscriptionSpecAzureFunctionEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecAzureFunctionEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SystemTopicEventSubscriptionSpecAzureFunctionEndpoint)(ptr) = obj
		} else {
			*(*SystemTopicEventSubscriptionSpecAzureFunctionEndpoint)(ptr) = SystemTopicEventSubscriptionSpecAzureFunctionEndpoint{}
		}
	default:
		iter.ReportError("decode SystemTopicEventSubscriptionSpecAzureFunctionEndpoint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SystemTopicEventSubscriptionSpecDeadLetterIdentityCodec struct {
}

func (SystemTopicEventSubscriptionSpecDeadLetterIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SystemTopicEventSubscriptionSpecDeadLetterIdentity)(ptr) == nil
}

func (SystemTopicEventSubscriptionSpecDeadLetterIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SystemTopicEventSubscriptionSpecDeadLetterIdentity)(ptr)
	var objs []SystemTopicEventSubscriptionSpecDeadLetterIdentity
	if obj != nil {
		objs = []SystemTopicEventSubscriptionSpecDeadLetterIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecDeadLetterIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SystemTopicEventSubscriptionSpecDeadLetterIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SystemTopicEventSubscriptionSpecDeadLetterIdentity)(ptr) = SystemTopicEventSubscriptionSpecDeadLetterIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SystemTopicEventSubscriptionSpecDeadLetterIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecDeadLetterIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SystemTopicEventSubscriptionSpecDeadLetterIdentity)(ptr) = objs[0]
			} else {
				*(*SystemTopicEventSubscriptionSpecDeadLetterIdentity)(ptr) = SystemTopicEventSubscriptionSpecDeadLetterIdentity{}
			}
		} else {
			*(*SystemTopicEventSubscriptionSpecDeadLetterIdentity)(ptr) = SystemTopicEventSubscriptionSpecDeadLetterIdentity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SystemTopicEventSubscriptionSpecDeadLetterIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecDeadLetterIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SystemTopicEventSubscriptionSpecDeadLetterIdentity)(ptr) = obj
		} else {
			*(*SystemTopicEventSubscriptionSpecDeadLetterIdentity)(ptr) = SystemTopicEventSubscriptionSpecDeadLetterIdentity{}
		}
	default:
		iter.ReportError("decode SystemTopicEventSubscriptionSpecDeadLetterIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SystemTopicEventSubscriptionSpecDeliveryIdentityCodec struct {
}

func (SystemTopicEventSubscriptionSpecDeliveryIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SystemTopicEventSubscriptionSpecDeliveryIdentity)(ptr) == nil
}

func (SystemTopicEventSubscriptionSpecDeliveryIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SystemTopicEventSubscriptionSpecDeliveryIdentity)(ptr)
	var objs []SystemTopicEventSubscriptionSpecDeliveryIdentity
	if obj != nil {
		objs = []SystemTopicEventSubscriptionSpecDeliveryIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecDeliveryIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SystemTopicEventSubscriptionSpecDeliveryIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SystemTopicEventSubscriptionSpecDeliveryIdentity)(ptr) = SystemTopicEventSubscriptionSpecDeliveryIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SystemTopicEventSubscriptionSpecDeliveryIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecDeliveryIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SystemTopicEventSubscriptionSpecDeliveryIdentity)(ptr) = objs[0]
			} else {
				*(*SystemTopicEventSubscriptionSpecDeliveryIdentity)(ptr) = SystemTopicEventSubscriptionSpecDeliveryIdentity{}
			}
		} else {
			*(*SystemTopicEventSubscriptionSpecDeliveryIdentity)(ptr) = SystemTopicEventSubscriptionSpecDeliveryIdentity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SystemTopicEventSubscriptionSpecDeliveryIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecDeliveryIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SystemTopicEventSubscriptionSpecDeliveryIdentity)(ptr) = obj
		} else {
			*(*SystemTopicEventSubscriptionSpecDeliveryIdentity)(ptr) = SystemTopicEventSubscriptionSpecDeliveryIdentity{}
		}
	default:
		iter.ReportError("decode SystemTopicEventSubscriptionSpecDeliveryIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SystemTopicEventSubscriptionSpecRetryPolicyCodec struct {
}

func (SystemTopicEventSubscriptionSpecRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SystemTopicEventSubscriptionSpecRetryPolicy)(ptr) == nil
}

func (SystemTopicEventSubscriptionSpecRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SystemTopicEventSubscriptionSpecRetryPolicy)(ptr)
	var objs []SystemTopicEventSubscriptionSpecRetryPolicy
	if obj != nil {
		objs = []SystemTopicEventSubscriptionSpecRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SystemTopicEventSubscriptionSpecRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SystemTopicEventSubscriptionSpecRetryPolicy)(ptr) = SystemTopicEventSubscriptionSpecRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SystemTopicEventSubscriptionSpecRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SystemTopicEventSubscriptionSpecRetryPolicy)(ptr) = objs[0]
			} else {
				*(*SystemTopicEventSubscriptionSpecRetryPolicy)(ptr) = SystemTopicEventSubscriptionSpecRetryPolicy{}
			}
		} else {
			*(*SystemTopicEventSubscriptionSpecRetryPolicy)(ptr) = SystemTopicEventSubscriptionSpecRetryPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SystemTopicEventSubscriptionSpecRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SystemTopicEventSubscriptionSpecRetryPolicy)(ptr) = obj
		} else {
			*(*SystemTopicEventSubscriptionSpecRetryPolicy)(ptr) = SystemTopicEventSubscriptionSpecRetryPolicy{}
		}
	default:
		iter.ReportError("decode SystemTopicEventSubscriptionSpecRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestinationCodec struct {
}

func (SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestinationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) == nil
}

func (SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestinationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr)
	var objs []SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination
	if obj != nil {
		objs = []SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestinationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) = SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) = objs[0]
			} else {
				*(*SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) = SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination{}
			}
		} else {
			*(*SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) = SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) = obj
		} else {
			*(*SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) = SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination{}
		}
	default:
		iter.ReportError("decode SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SystemTopicEventSubscriptionSpecStorageQueueEndpointCodec struct {
}

func (SystemTopicEventSubscriptionSpecStorageQueueEndpointCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SystemTopicEventSubscriptionSpecStorageQueueEndpoint)(ptr) == nil
}

func (SystemTopicEventSubscriptionSpecStorageQueueEndpointCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SystemTopicEventSubscriptionSpecStorageQueueEndpoint)(ptr)
	var objs []SystemTopicEventSubscriptionSpecStorageQueueEndpoint
	if obj != nil {
		objs = []SystemTopicEventSubscriptionSpecStorageQueueEndpoint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecStorageQueueEndpoint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SystemTopicEventSubscriptionSpecStorageQueueEndpointCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SystemTopicEventSubscriptionSpecStorageQueueEndpoint)(ptr) = SystemTopicEventSubscriptionSpecStorageQueueEndpoint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SystemTopicEventSubscriptionSpecStorageQueueEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecStorageQueueEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SystemTopicEventSubscriptionSpecStorageQueueEndpoint)(ptr) = objs[0]
			} else {
				*(*SystemTopicEventSubscriptionSpecStorageQueueEndpoint)(ptr) = SystemTopicEventSubscriptionSpecStorageQueueEndpoint{}
			}
		} else {
			*(*SystemTopicEventSubscriptionSpecStorageQueueEndpoint)(ptr) = SystemTopicEventSubscriptionSpecStorageQueueEndpoint{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SystemTopicEventSubscriptionSpecStorageQueueEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecStorageQueueEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SystemTopicEventSubscriptionSpecStorageQueueEndpoint)(ptr) = obj
		} else {
			*(*SystemTopicEventSubscriptionSpecStorageQueueEndpoint)(ptr) = SystemTopicEventSubscriptionSpecStorageQueueEndpoint{}
		}
	default:
		iter.ReportError("decode SystemTopicEventSubscriptionSpecStorageQueueEndpoint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SystemTopicEventSubscriptionSpecSubjectFilterCodec struct {
}

func (SystemTopicEventSubscriptionSpecSubjectFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SystemTopicEventSubscriptionSpecSubjectFilter)(ptr) == nil
}

func (SystemTopicEventSubscriptionSpecSubjectFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SystemTopicEventSubscriptionSpecSubjectFilter)(ptr)
	var objs []SystemTopicEventSubscriptionSpecSubjectFilter
	if obj != nil {
		objs = []SystemTopicEventSubscriptionSpecSubjectFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecSubjectFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SystemTopicEventSubscriptionSpecSubjectFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SystemTopicEventSubscriptionSpecSubjectFilter)(ptr) = SystemTopicEventSubscriptionSpecSubjectFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SystemTopicEventSubscriptionSpecSubjectFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecSubjectFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SystemTopicEventSubscriptionSpecSubjectFilter)(ptr) = objs[0]
			} else {
				*(*SystemTopicEventSubscriptionSpecSubjectFilter)(ptr) = SystemTopicEventSubscriptionSpecSubjectFilter{}
			}
		} else {
			*(*SystemTopicEventSubscriptionSpecSubjectFilter)(ptr) = SystemTopicEventSubscriptionSpecSubjectFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SystemTopicEventSubscriptionSpecSubjectFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecSubjectFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SystemTopicEventSubscriptionSpecSubjectFilter)(ptr) = obj
		} else {
			*(*SystemTopicEventSubscriptionSpecSubjectFilter)(ptr) = SystemTopicEventSubscriptionSpecSubjectFilter{}
		}
	default:
		iter.ReportError("decode SystemTopicEventSubscriptionSpecSubjectFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SystemTopicEventSubscriptionSpecWebhookEndpointCodec struct {
}

func (SystemTopicEventSubscriptionSpecWebhookEndpointCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SystemTopicEventSubscriptionSpecWebhookEndpoint)(ptr) == nil
}

func (SystemTopicEventSubscriptionSpecWebhookEndpointCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SystemTopicEventSubscriptionSpecWebhookEndpoint)(ptr)
	var objs []SystemTopicEventSubscriptionSpecWebhookEndpoint
	if obj != nil {
		objs = []SystemTopicEventSubscriptionSpecWebhookEndpoint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecWebhookEndpoint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SystemTopicEventSubscriptionSpecWebhookEndpointCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SystemTopicEventSubscriptionSpecWebhookEndpoint)(ptr) = SystemTopicEventSubscriptionSpecWebhookEndpoint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SystemTopicEventSubscriptionSpecWebhookEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecWebhookEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SystemTopicEventSubscriptionSpecWebhookEndpoint)(ptr) = objs[0]
			} else {
				*(*SystemTopicEventSubscriptionSpecWebhookEndpoint)(ptr) = SystemTopicEventSubscriptionSpecWebhookEndpoint{}
			}
		} else {
			*(*SystemTopicEventSubscriptionSpecWebhookEndpoint)(ptr) = SystemTopicEventSubscriptionSpecWebhookEndpoint{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SystemTopicEventSubscriptionSpecWebhookEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecWebhookEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SystemTopicEventSubscriptionSpecWebhookEndpoint)(ptr) = obj
		} else {
			*(*SystemTopicEventSubscriptionSpecWebhookEndpoint)(ptr) = SystemTopicEventSubscriptionSpecWebhookEndpoint{}
		}
	default:
		iter.ReportError("decode SystemTopicEventSubscriptionSpecWebhookEndpoint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicSpecIdentityCodec struct {
}

func (TopicSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicSpecIdentity)(ptr) == nil
}

func (TopicSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicSpecIdentity)(ptr)
	var objs []TopicSpecIdentity
	if obj != nil {
		objs = []TopicSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicSpecIdentity)(ptr) = TopicSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicSpecIdentity)(ptr) = objs[0]
			} else {
				*(*TopicSpecIdentity)(ptr) = TopicSpecIdentity{}
			}
		} else {
			*(*TopicSpecIdentity)(ptr) = TopicSpecIdentity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TopicSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TopicSpecIdentity)(ptr) = obj
		} else {
			*(*TopicSpecIdentity)(ptr) = TopicSpecIdentity{}
		}
	default:
		iter.ReportError("decode TopicSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicSpecInputMappingDefaultValuesCodec struct {
}

func (TopicSpecInputMappingDefaultValuesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicSpecInputMappingDefaultValues)(ptr) == nil
}

func (TopicSpecInputMappingDefaultValuesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicSpecInputMappingDefaultValues)(ptr)
	var objs []TopicSpecInputMappingDefaultValues
	if obj != nil {
		objs = []TopicSpecInputMappingDefaultValues{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecInputMappingDefaultValues{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicSpecInputMappingDefaultValuesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicSpecInputMappingDefaultValues)(ptr) = TopicSpecInputMappingDefaultValues{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicSpecInputMappingDefaultValues

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecInputMappingDefaultValues{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicSpecInputMappingDefaultValues)(ptr) = objs[0]
			} else {
				*(*TopicSpecInputMappingDefaultValues)(ptr) = TopicSpecInputMappingDefaultValues{}
			}
		} else {
			*(*TopicSpecInputMappingDefaultValues)(ptr) = TopicSpecInputMappingDefaultValues{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TopicSpecInputMappingDefaultValues

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecInputMappingDefaultValues{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TopicSpecInputMappingDefaultValues)(ptr) = obj
		} else {
			*(*TopicSpecInputMappingDefaultValues)(ptr) = TopicSpecInputMappingDefaultValues{}
		}
	default:
		iter.ReportError("decode TopicSpecInputMappingDefaultValues", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicSpecInputMappingFieldsCodec struct {
}

func (TopicSpecInputMappingFieldsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicSpecInputMappingFields)(ptr) == nil
}

func (TopicSpecInputMappingFieldsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicSpecInputMappingFields)(ptr)
	var objs []TopicSpecInputMappingFields
	if obj != nil {
		objs = []TopicSpecInputMappingFields{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecInputMappingFields{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicSpecInputMappingFieldsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicSpecInputMappingFields)(ptr) = TopicSpecInputMappingFields{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicSpecInputMappingFields

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecInputMappingFields{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicSpecInputMappingFields)(ptr) = objs[0]
			} else {
				*(*TopicSpecInputMappingFields)(ptr) = TopicSpecInputMappingFields{}
			}
		} else {
			*(*TopicSpecInputMappingFields)(ptr) = TopicSpecInputMappingFields{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj TopicSpecInputMappingFields

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecInputMappingFields{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*TopicSpecInputMappingFields)(ptr) = obj
		} else {
			*(*TopicSpecInputMappingFields)(ptr) = TopicSpecInputMappingFields{}
		}
	default:
		iter.ReportError("decode TopicSpecInputMappingFields", "unexpected JSON type")
	}
}

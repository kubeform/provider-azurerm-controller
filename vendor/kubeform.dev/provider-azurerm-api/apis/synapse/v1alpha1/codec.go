/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(LinkedServiceSpecIntegrationRuntime{}).Type1()):                LinkedServiceSpecIntegrationRuntimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecAutoPause{}).Type1()):                             SparkPoolSpecAutoPauseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecAutoScale{}).Type1()):                             SparkPoolSpecAutoScaleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecLibraryRequirement{}).Type1()):                    SparkPoolSpecLibraryRequirementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecSparkConfig{}).Type1()):                           SparkPoolSpecSparkConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SqlPoolSpecRestore{}).Type1()):                                 SqlPoolSpecRestoreCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SqlPoolVulnerabilityAssessmentSpecRecurringScans{}).Type1()):   SqlPoolVulnerabilityAssessmentSpecRecurringScansCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecAadAdmin{}).Type1()):                              WorkspaceSpecAadAdminCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecAzureDevopsRepo{}).Type1()):                       WorkspaceSpecAzureDevopsRepoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecCustomerManagedKey{}).Type1()):                    WorkspaceSpecCustomerManagedKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecGithubRepo{}).Type1()):                            WorkspaceSpecGithubRepoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecSqlAadAdmin{}).Type1()):                           WorkspaceSpecSqlAadAdminCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceVulnerabilityAssessmentSpecRecurringScans{}).Type1()): WorkspaceVulnerabilityAssessmentSpecRecurringScansCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(LinkedServiceSpecIntegrationRuntime{}).Type1()):                LinkedServiceSpecIntegrationRuntimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecAutoPause{}).Type1()):                             SparkPoolSpecAutoPauseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecAutoScale{}).Type1()):                             SparkPoolSpecAutoScaleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecLibraryRequirement{}).Type1()):                    SparkPoolSpecLibraryRequirementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecSparkConfig{}).Type1()):                           SparkPoolSpecSparkConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SqlPoolSpecRestore{}).Type1()):                                 SqlPoolSpecRestoreCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SqlPoolVulnerabilityAssessmentSpecRecurringScans{}).Type1()):   SqlPoolVulnerabilityAssessmentSpecRecurringScansCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecAadAdmin{}).Type1()):                              WorkspaceSpecAadAdminCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecAzureDevopsRepo{}).Type1()):                       WorkspaceSpecAzureDevopsRepoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecCustomerManagedKey{}).Type1()):                    WorkspaceSpecCustomerManagedKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecGithubRepo{}).Type1()):                            WorkspaceSpecGithubRepoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecSqlAadAdmin{}).Type1()):                           WorkspaceSpecSqlAadAdminCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceVulnerabilityAssessmentSpecRecurringScans{}).Type1()): WorkspaceVulnerabilityAssessmentSpecRecurringScansCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type LinkedServiceSpecIntegrationRuntimeCodec struct {
}

func (LinkedServiceSpecIntegrationRuntimeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LinkedServiceSpecIntegrationRuntime)(ptr) == nil
}

func (LinkedServiceSpecIntegrationRuntimeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LinkedServiceSpecIntegrationRuntime)(ptr)
	var objs []LinkedServiceSpecIntegrationRuntime
	if obj != nil {
		objs = []LinkedServiceSpecIntegrationRuntime{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LinkedServiceSpecIntegrationRuntime{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LinkedServiceSpecIntegrationRuntimeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LinkedServiceSpecIntegrationRuntime)(ptr) = LinkedServiceSpecIntegrationRuntime{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LinkedServiceSpecIntegrationRuntime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LinkedServiceSpecIntegrationRuntime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LinkedServiceSpecIntegrationRuntime)(ptr) = objs[0]
			} else {
				*(*LinkedServiceSpecIntegrationRuntime)(ptr) = LinkedServiceSpecIntegrationRuntime{}
			}
		} else {
			*(*LinkedServiceSpecIntegrationRuntime)(ptr) = LinkedServiceSpecIntegrationRuntime{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj LinkedServiceSpecIntegrationRuntime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LinkedServiceSpecIntegrationRuntime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*LinkedServiceSpecIntegrationRuntime)(ptr) = obj
		} else {
			*(*LinkedServiceSpecIntegrationRuntime)(ptr) = LinkedServiceSpecIntegrationRuntime{}
		}
	default:
		iter.ReportError("decode LinkedServiceSpecIntegrationRuntime", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkPoolSpecAutoPauseCodec struct {
}

func (SparkPoolSpecAutoPauseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkPoolSpecAutoPause)(ptr) == nil
}

func (SparkPoolSpecAutoPauseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkPoolSpecAutoPause)(ptr)
	var objs []SparkPoolSpecAutoPause
	if obj != nil {
		objs = []SparkPoolSpecAutoPause{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecAutoPause{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkPoolSpecAutoPauseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkPoolSpecAutoPause)(ptr) = SparkPoolSpecAutoPause{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkPoolSpecAutoPause

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecAutoPause{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkPoolSpecAutoPause)(ptr) = objs[0]
			} else {
				*(*SparkPoolSpecAutoPause)(ptr) = SparkPoolSpecAutoPause{}
			}
		} else {
			*(*SparkPoolSpecAutoPause)(ptr) = SparkPoolSpecAutoPause{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SparkPoolSpecAutoPause

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecAutoPause{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SparkPoolSpecAutoPause)(ptr) = obj
		} else {
			*(*SparkPoolSpecAutoPause)(ptr) = SparkPoolSpecAutoPause{}
		}
	default:
		iter.ReportError("decode SparkPoolSpecAutoPause", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkPoolSpecAutoScaleCodec struct {
}

func (SparkPoolSpecAutoScaleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkPoolSpecAutoScale)(ptr) == nil
}

func (SparkPoolSpecAutoScaleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkPoolSpecAutoScale)(ptr)
	var objs []SparkPoolSpecAutoScale
	if obj != nil {
		objs = []SparkPoolSpecAutoScale{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecAutoScale{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkPoolSpecAutoScaleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkPoolSpecAutoScale)(ptr) = SparkPoolSpecAutoScale{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkPoolSpecAutoScale

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecAutoScale{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkPoolSpecAutoScale)(ptr) = objs[0]
			} else {
				*(*SparkPoolSpecAutoScale)(ptr) = SparkPoolSpecAutoScale{}
			}
		} else {
			*(*SparkPoolSpecAutoScale)(ptr) = SparkPoolSpecAutoScale{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SparkPoolSpecAutoScale

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecAutoScale{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SparkPoolSpecAutoScale)(ptr) = obj
		} else {
			*(*SparkPoolSpecAutoScale)(ptr) = SparkPoolSpecAutoScale{}
		}
	default:
		iter.ReportError("decode SparkPoolSpecAutoScale", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkPoolSpecLibraryRequirementCodec struct {
}

func (SparkPoolSpecLibraryRequirementCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkPoolSpecLibraryRequirement)(ptr) == nil
}

func (SparkPoolSpecLibraryRequirementCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkPoolSpecLibraryRequirement)(ptr)
	var objs []SparkPoolSpecLibraryRequirement
	if obj != nil {
		objs = []SparkPoolSpecLibraryRequirement{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecLibraryRequirement{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkPoolSpecLibraryRequirementCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkPoolSpecLibraryRequirement)(ptr) = SparkPoolSpecLibraryRequirement{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkPoolSpecLibraryRequirement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecLibraryRequirement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkPoolSpecLibraryRequirement)(ptr) = objs[0]
			} else {
				*(*SparkPoolSpecLibraryRequirement)(ptr) = SparkPoolSpecLibraryRequirement{}
			}
		} else {
			*(*SparkPoolSpecLibraryRequirement)(ptr) = SparkPoolSpecLibraryRequirement{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SparkPoolSpecLibraryRequirement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecLibraryRequirement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SparkPoolSpecLibraryRequirement)(ptr) = obj
		} else {
			*(*SparkPoolSpecLibraryRequirement)(ptr) = SparkPoolSpecLibraryRequirement{}
		}
	default:
		iter.ReportError("decode SparkPoolSpecLibraryRequirement", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkPoolSpecSparkConfigCodec struct {
}

func (SparkPoolSpecSparkConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkPoolSpecSparkConfig)(ptr) == nil
}

func (SparkPoolSpecSparkConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkPoolSpecSparkConfig)(ptr)
	var objs []SparkPoolSpecSparkConfig
	if obj != nil {
		objs = []SparkPoolSpecSparkConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecSparkConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkPoolSpecSparkConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkPoolSpecSparkConfig)(ptr) = SparkPoolSpecSparkConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkPoolSpecSparkConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecSparkConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkPoolSpecSparkConfig)(ptr) = objs[0]
			} else {
				*(*SparkPoolSpecSparkConfig)(ptr) = SparkPoolSpecSparkConfig{}
			}
		} else {
			*(*SparkPoolSpecSparkConfig)(ptr) = SparkPoolSpecSparkConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SparkPoolSpecSparkConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecSparkConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SparkPoolSpecSparkConfig)(ptr) = obj
		} else {
			*(*SparkPoolSpecSparkConfig)(ptr) = SparkPoolSpecSparkConfig{}
		}
	default:
		iter.ReportError("decode SparkPoolSpecSparkConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SqlPoolSpecRestoreCodec struct {
}

func (SqlPoolSpecRestoreCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SqlPoolSpecRestore)(ptr) == nil
}

func (SqlPoolSpecRestoreCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SqlPoolSpecRestore)(ptr)
	var objs []SqlPoolSpecRestore
	if obj != nil {
		objs = []SqlPoolSpecRestore{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SqlPoolSpecRestore{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SqlPoolSpecRestoreCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SqlPoolSpecRestore)(ptr) = SqlPoolSpecRestore{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SqlPoolSpecRestore

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SqlPoolSpecRestore{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SqlPoolSpecRestore)(ptr) = objs[0]
			} else {
				*(*SqlPoolSpecRestore)(ptr) = SqlPoolSpecRestore{}
			}
		} else {
			*(*SqlPoolSpecRestore)(ptr) = SqlPoolSpecRestore{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SqlPoolSpecRestore

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SqlPoolSpecRestore{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SqlPoolSpecRestore)(ptr) = obj
		} else {
			*(*SqlPoolSpecRestore)(ptr) = SqlPoolSpecRestore{}
		}
	default:
		iter.ReportError("decode SqlPoolSpecRestore", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SqlPoolVulnerabilityAssessmentSpecRecurringScansCodec struct {
}

func (SqlPoolVulnerabilityAssessmentSpecRecurringScansCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SqlPoolVulnerabilityAssessmentSpecRecurringScans)(ptr) == nil
}

func (SqlPoolVulnerabilityAssessmentSpecRecurringScansCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SqlPoolVulnerabilityAssessmentSpecRecurringScans)(ptr)
	var objs []SqlPoolVulnerabilityAssessmentSpecRecurringScans
	if obj != nil {
		objs = []SqlPoolVulnerabilityAssessmentSpecRecurringScans{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SqlPoolVulnerabilityAssessmentSpecRecurringScans{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SqlPoolVulnerabilityAssessmentSpecRecurringScansCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SqlPoolVulnerabilityAssessmentSpecRecurringScans)(ptr) = SqlPoolVulnerabilityAssessmentSpecRecurringScans{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SqlPoolVulnerabilityAssessmentSpecRecurringScans

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SqlPoolVulnerabilityAssessmentSpecRecurringScans{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SqlPoolVulnerabilityAssessmentSpecRecurringScans)(ptr) = objs[0]
			} else {
				*(*SqlPoolVulnerabilityAssessmentSpecRecurringScans)(ptr) = SqlPoolVulnerabilityAssessmentSpecRecurringScans{}
			}
		} else {
			*(*SqlPoolVulnerabilityAssessmentSpecRecurringScans)(ptr) = SqlPoolVulnerabilityAssessmentSpecRecurringScans{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SqlPoolVulnerabilityAssessmentSpecRecurringScans

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SqlPoolVulnerabilityAssessmentSpecRecurringScans{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SqlPoolVulnerabilityAssessmentSpecRecurringScans)(ptr) = obj
		} else {
			*(*SqlPoolVulnerabilityAssessmentSpecRecurringScans)(ptr) = SqlPoolVulnerabilityAssessmentSpecRecurringScans{}
		}
	default:
		iter.ReportError("decode SqlPoolVulnerabilityAssessmentSpecRecurringScans", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkspaceSpecAadAdminCodec struct {
}

func (WorkspaceSpecAadAdminCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkspaceSpecAadAdmin)(ptr) == nil
}

func (WorkspaceSpecAadAdminCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkspaceSpecAadAdmin)(ptr)
	var objs []WorkspaceSpecAadAdmin
	if obj != nil {
		objs = []WorkspaceSpecAadAdmin{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecAadAdmin{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkspaceSpecAadAdminCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkspaceSpecAadAdmin)(ptr) = WorkspaceSpecAadAdmin{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkspaceSpecAadAdmin

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecAadAdmin{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkspaceSpecAadAdmin)(ptr) = objs[0]
			} else {
				*(*WorkspaceSpecAadAdmin)(ptr) = WorkspaceSpecAadAdmin{}
			}
		} else {
			*(*WorkspaceSpecAadAdmin)(ptr) = WorkspaceSpecAadAdmin{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkspaceSpecAadAdmin

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecAadAdmin{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkspaceSpecAadAdmin)(ptr) = obj
		} else {
			*(*WorkspaceSpecAadAdmin)(ptr) = WorkspaceSpecAadAdmin{}
		}
	default:
		iter.ReportError("decode WorkspaceSpecAadAdmin", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkspaceSpecAzureDevopsRepoCodec struct {
}

func (WorkspaceSpecAzureDevopsRepoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkspaceSpecAzureDevopsRepo)(ptr) == nil
}

func (WorkspaceSpecAzureDevopsRepoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkspaceSpecAzureDevopsRepo)(ptr)
	var objs []WorkspaceSpecAzureDevopsRepo
	if obj != nil {
		objs = []WorkspaceSpecAzureDevopsRepo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecAzureDevopsRepo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkspaceSpecAzureDevopsRepoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkspaceSpecAzureDevopsRepo)(ptr) = WorkspaceSpecAzureDevopsRepo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkspaceSpecAzureDevopsRepo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecAzureDevopsRepo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkspaceSpecAzureDevopsRepo)(ptr) = objs[0]
			} else {
				*(*WorkspaceSpecAzureDevopsRepo)(ptr) = WorkspaceSpecAzureDevopsRepo{}
			}
		} else {
			*(*WorkspaceSpecAzureDevopsRepo)(ptr) = WorkspaceSpecAzureDevopsRepo{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkspaceSpecAzureDevopsRepo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecAzureDevopsRepo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkspaceSpecAzureDevopsRepo)(ptr) = obj
		} else {
			*(*WorkspaceSpecAzureDevopsRepo)(ptr) = WorkspaceSpecAzureDevopsRepo{}
		}
	default:
		iter.ReportError("decode WorkspaceSpecAzureDevopsRepo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkspaceSpecCustomerManagedKeyCodec struct {
}

func (WorkspaceSpecCustomerManagedKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkspaceSpecCustomerManagedKey)(ptr) == nil
}

func (WorkspaceSpecCustomerManagedKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkspaceSpecCustomerManagedKey)(ptr)
	var objs []WorkspaceSpecCustomerManagedKey
	if obj != nil {
		objs = []WorkspaceSpecCustomerManagedKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecCustomerManagedKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkspaceSpecCustomerManagedKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkspaceSpecCustomerManagedKey)(ptr) = WorkspaceSpecCustomerManagedKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkspaceSpecCustomerManagedKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecCustomerManagedKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkspaceSpecCustomerManagedKey)(ptr) = objs[0]
			} else {
				*(*WorkspaceSpecCustomerManagedKey)(ptr) = WorkspaceSpecCustomerManagedKey{}
			}
		} else {
			*(*WorkspaceSpecCustomerManagedKey)(ptr) = WorkspaceSpecCustomerManagedKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkspaceSpecCustomerManagedKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecCustomerManagedKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkspaceSpecCustomerManagedKey)(ptr) = obj
		} else {
			*(*WorkspaceSpecCustomerManagedKey)(ptr) = WorkspaceSpecCustomerManagedKey{}
		}
	default:
		iter.ReportError("decode WorkspaceSpecCustomerManagedKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkspaceSpecGithubRepoCodec struct {
}

func (WorkspaceSpecGithubRepoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkspaceSpecGithubRepo)(ptr) == nil
}

func (WorkspaceSpecGithubRepoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkspaceSpecGithubRepo)(ptr)
	var objs []WorkspaceSpecGithubRepo
	if obj != nil {
		objs = []WorkspaceSpecGithubRepo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecGithubRepo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkspaceSpecGithubRepoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkspaceSpecGithubRepo)(ptr) = WorkspaceSpecGithubRepo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkspaceSpecGithubRepo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecGithubRepo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkspaceSpecGithubRepo)(ptr) = objs[0]
			} else {
				*(*WorkspaceSpecGithubRepo)(ptr) = WorkspaceSpecGithubRepo{}
			}
		} else {
			*(*WorkspaceSpecGithubRepo)(ptr) = WorkspaceSpecGithubRepo{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkspaceSpecGithubRepo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecGithubRepo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkspaceSpecGithubRepo)(ptr) = obj
		} else {
			*(*WorkspaceSpecGithubRepo)(ptr) = WorkspaceSpecGithubRepo{}
		}
	default:
		iter.ReportError("decode WorkspaceSpecGithubRepo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkspaceSpecSqlAadAdminCodec struct {
}

func (WorkspaceSpecSqlAadAdminCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkspaceSpecSqlAadAdmin)(ptr) == nil
}

func (WorkspaceSpecSqlAadAdminCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkspaceSpecSqlAadAdmin)(ptr)
	var objs []WorkspaceSpecSqlAadAdmin
	if obj != nil {
		objs = []WorkspaceSpecSqlAadAdmin{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecSqlAadAdmin{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkspaceSpecSqlAadAdminCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkspaceSpecSqlAadAdmin)(ptr) = WorkspaceSpecSqlAadAdmin{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkspaceSpecSqlAadAdmin

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecSqlAadAdmin{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkspaceSpecSqlAadAdmin)(ptr) = objs[0]
			} else {
				*(*WorkspaceSpecSqlAadAdmin)(ptr) = WorkspaceSpecSqlAadAdmin{}
			}
		} else {
			*(*WorkspaceSpecSqlAadAdmin)(ptr) = WorkspaceSpecSqlAadAdmin{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkspaceSpecSqlAadAdmin

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecSqlAadAdmin{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkspaceSpecSqlAadAdmin)(ptr) = obj
		} else {
			*(*WorkspaceSpecSqlAadAdmin)(ptr) = WorkspaceSpecSqlAadAdmin{}
		}
	default:
		iter.ReportError("decode WorkspaceSpecSqlAadAdmin", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkspaceVulnerabilityAssessmentSpecRecurringScansCodec struct {
}

func (WorkspaceVulnerabilityAssessmentSpecRecurringScansCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkspaceVulnerabilityAssessmentSpecRecurringScans)(ptr) == nil
}

func (WorkspaceVulnerabilityAssessmentSpecRecurringScansCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkspaceVulnerabilityAssessmentSpecRecurringScans)(ptr)
	var objs []WorkspaceVulnerabilityAssessmentSpecRecurringScans
	if obj != nil {
		objs = []WorkspaceVulnerabilityAssessmentSpecRecurringScans{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceVulnerabilityAssessmentSpecRecurringScans{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkspaceVulnerabilityAssessmentSpecRecurringScansCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkspaceVulnerabilityAssessmentSpecRecurringScans)(ptr) = WorkspaceVulnerabilityAssessmentSpecRecurringScans{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkspaceVulnerabilityAssessmentSpecRecurringScans

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceVulnerabilityAssessmentSpecRecurringScans{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkspaceVulnerabilityAssessmentSpecRecurringScans)(ptr) = objs[0]
			} else {
				*(*WorkspaceVulnerabilityAssessmentSpecRecurringScans)(ptr) = WorkspaceVulnerabilityAssessmentSpecRecurringScans{}
			}
		} else {
			*(*WorkspaceVulnerabilityAssessmentSpecRecurringScans)(ptr) = WorkspaceVulnerabilityAssessmentSpecRecurringScans{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj WorkspaceVulnerabilityAssessmentSpecRecurringScans

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceVulnerabilityAssessmentSpecRecurringScans{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*WorkspaceVulnerabilityAssessmentSpecRecurringScans)(ptr) = obj
		} else {
			*(*WorkspaceVulnerabilityAssessmentSpecRecurringScans)(ptr) = WorkspaceVulnerabilityAssessmentSpecRecurringScans{}
		}
	default:
		iter.ReportError("decode WorkspaceVulnerabilityAssessmentSpecRecurringScans", "unexpected JSON type")
	}
}

/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfile{}).Type1()):                               KubernetesClusterSpecAddonProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileAciConnectorLinux{}).Type1()):              KubernetesClusterSpecAddonProfileAciConnectorLinuxCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileAzurePolicy{}).Type1()):                    KubernetesClusterSpecAddonProfileAzurePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileHttpApplicationRouting{}).Type1()):         KubernetesClusterSpecAddonProfileHttpApplicationRoutingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileIngressApplicationGateway{}).Type1()):      KubernetesClusterSpecAddonProfileIngressApplicationGatewayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileKubeDashboard{}).Type1()):                  KubernetesClusterSpecAddonProfileKubeDashboardCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileOmsAgent{}).Type1()):                       KubernetesClusterSpecAddonProfileOmsAgentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAutoScalerProfile{}).Type1()):                          KubernetesClusterSpecAutoScalerProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePool{}).Type1()):                            KubernetesClusterSpecDefaultNodePoolCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolKubeletConfig{}).Type1()):               KubernetesClusterSpecDefaultNodePoolKubeletConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolLinuxOsConfig{}).Type1()):               KubernetesClusterSpecDefaultNodePoolLinuxOsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig{}).Type1()):   KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolUpgradeSettings{}).Type1()):             KubernetesClusterSpecDefaultNodePoolUpgradeSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecIdentity{}).Type1()):                                   KubernetesClusterSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecKubeletIdentity{}).Type1()):                            KubernetesClusterSpecKubeletIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecLinuxProfile{}).Type1()):                               KubernetesClusterSpecLinuxProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecLinuxProfileSshKey{}).Type1()):                         KubernetesClusterSpecLinuxProfileSshKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecNetworkProfile{}).Type1()):                             KubernetesClusterSpecNetworkProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecNetworkProfileLoadBalancerProfile{}).Type1()):          KubernetesClusterSpecNetworkProfileLoadBalancerProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecRoleBasedAccessControl{}).Type1()):                     KubernetesClusterSpecRoleBasedAccessControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory{}).Type1()): KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectoryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecServicePrincipal{}).Type1()):                           KubernetesClusterSpecServicePrincipalCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecWindowsProfile{}).Type1()):                             KubernetesClusterSpecWindowsProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecKubeletConfig{}).Type1()):                                       NodePoolSpecKubeletConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecLinuxOsConfig{}).Type1()):                                       NodePoolSpecLinuxOsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecLinuxOsConfigSysctlConfig{}).Type1()):                           NodePoolSpecLinuxOsConfigSysctlConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecUpgradeSettings{}).Type1()):                                     NodePoolSpecUpgradeSettingsCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfile{}).Type1()):                               KubernetesClusterSpecAddonProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileAciConnectorLinux{}).Type1()):              KubernetesClusterSpecAddonProfileAciConnectorLinuxCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileAzurePolicy{}).Type1()):                    KubernetesClusterSpecAddonProfileAzurePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileHttpApplicationRouting{}).Type1()):         KubernetesClusterSpecAddonProfileHttpApplicationRoutingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileIngressApplicationGateway{}).Type1()):      KubernetesClusterSpecAddonProfileIngressApplicationGatewayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileKubeDashboard{}).Type1()):                  KubernetesClusterSpecAddonProfileKubeDashboardCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileOmsAgent{}).Type1()):                       KubernetesClusterSpecAddonProfileOmsAgentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAutoScalerProfile{}).Type1()):                          KubernetesClusterSpecAutoScalerProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePool{}).Type1()):                            KubernetesClusterSpecDefaultNodePoolCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolKubeletConfig{}).Type1()):               KubernetesClusterSpecDefaultNodePoolKubeletConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolLinuxOsConfig{}).Type1()):               KubernetesClusterSpecDefaultNodePoolLinuxOsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig{}).Type1()):   KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolUpgradeSettings{}).Type1()):             KubernetesClusterSpecDefaultNodePoolUpgradeSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecIdentity{}).Type1()):                                   KubernetesClusterSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecKubeletIdentity{}).Type1()):                            KubernetesClusterSpecKubeletIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecLinuxProfile{}).Type1()):                               KubernetesClusterSpecLinuxProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecLinuxProfileSshKey{}).Type1()):                         KubernetesClusterSpecLinuxProfileSshKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecNetworkProfile{}).Type1()):                             KubernetesClusterSpecNetworkProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecNetworkProfileLoadBalancerProfile{}).Type1()):          KubernetesClusterSpecNetworkProfileLoadBalancerProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecRoleBasedAccessControl{}).Type1()):                     KubernetesClusterSpecRoleBasedAccessControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory{}).Type1()): KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectoryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecServicePrincipal{}).Type1()):                           KubernetesClusterSpecServicePrincipalCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecWindowsProfile{}).Type1()):                             KubernetesClusterSpecWindowsProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecKubeletConfig{}).Type1()):                                       NodePoolSpecKubeletConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecLinuxOsConfig{}).Type1()):                                       NodePoolSpecLinuxOsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecLinuxOsConfigSysctlConfig{}).Type1()):                           NodePoolSpecLinuxOsConfigSysctlConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecUpgradeSettings{}).Type1()):                                     NodePoolSpecUpgradeSettingsCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecAddonProfileCodec struct {
}

func (KubernetesClusterSpecAddonProfileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecAddonProfile)(ptr) == nil
}

func (KubernetesClusterSpecAddonProfileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecAddonProfile)(ptr)
	var objs []KubernetesClusterSpecAddonProfile
	if obj != nil {
		objs = []KubernetesClusterSpecAddonProfile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecAddonProfileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecAddonProfile)(ptr) = KubernetesClusterSpecAddonProfile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecAddonProfile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecAddonProfile)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecAddonProfile)(ptr) = KubernetesClusterSpecAddonProfile{}
			}
		} else {
			*(*KubernetesClusterSpecAddonProfile)(ptr) = KubernetesClusterSpecAddonProfile{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecAddonProfile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecAddonProfile)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecAddonProfile)(ptr) = KubernetesClusterSpecAddonProfile{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecAddonProfile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecAddonProfileAciConnectorLinuxCodec struct {
}

func (KubernetesClusterSpecAddonProfileAciConnectorLinuxCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecAddonProfileAciConnectorLinux)(ptr) == nil
}

func (KubernetesClusterSpecAddonProfileAciConnectorLinuxCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecAddonProfileAciConnectorLinux)(ptr)
	var objs []KubernetesClusterSpecAddonProfileAciConnectorLinux
	if obj != nil {
		objs = []KubernetesClusterSpecAddonProfileAciConnectorLinux{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileAciConnectorLinux{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecAddonProfileAciConnectorLinuxCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecAddonProfileAciConnectorLinux)(ptr) = KubernetesClusterSpecAddonProfileAciConnectorLinux{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecAddonProfileAciConnectorLinux

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileAciConnectorLinux{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecAddonProfileAciConnectorLinux)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecAddonProfileAciConnectorLinux)(ptr) = KubernetesClusterSpecAddonProfileAciConnectorLinux{}
			}
		} else {
			*(*KubernetesClusterSpecAddonProfileAciConnectorLinux)(ptr) = KubernetesClusterSpecAddonProfileAciConnectorLinux{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecAddonProfileAciConnectorLinux

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileAciConnectorLinux{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecAddonProfileAciConnectorLinux)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecAddonProfileAciConnectorLinux)(ptr) = KubernetesClusterSpecAddonProfileAciConnectorLinux{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecAddonProfileAciConnectorLinux", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecAddonProfileAzurePolicyCodec struct {
}

func (KubernetesClusterSpecAddonProfileAzurePolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecAddonProfileAzurePolicy)(ptr) == nil
}

func (KubernetesClusterSpecAddonProfileAzurePolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecAddonProfileAzurePolicy)(ptr)
	var objs []KubernetesClusterSpecAddonProfileAzurePolicy
	if obj != nil {
		objs = []KubernetesClusterSpecAddonProfileAzurePolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileAzurePolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecAddonProfileAzurePolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecAddonProfileAzurePolicy)(ptr) = KubernetesClusterSpecAddonProfileAzurePolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecAddonProfileAzurePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileAzurePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecAddonProfileAzurePolicy)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecAddonProfileAzurePolicy)(ptr) = KubernetesClusterSpecAddonProfileAzurePolicy{}
			}
		} else {
			*(*KubernetesClusterSpecAddonProfileAzurePolicy)(ptr) = KubernetesClusterSpecAddonProfileAzurePolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecAddonProfileAzurePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileAzurePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecAddonProfileAzurePolicy)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecAddonProfileAzurePolicy)(ptr) = KubernetesClusterSpecAddonProfileAzurePolicy{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecAddonProfileAzurePolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecAddonProfileHttpApplicationRoutingCodec struct {
}

func (KubernetesClusterSpecAddonProfileHttpApplicationRoutingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecAddonProfileHttpApplicationRouting)(ptr) == nil
}

func (KubernetesClusterSpecAddonProfileHttpApplicationRoutingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecAddonProfileHttpApplicationRouting)(ptr)
	var objs []KubernetesClusterSpecAddonProfileHttpApplicationRouting
	if obj != nil {
		objs = []KubernetesClusterSpecAddonProfileHttpApplicationRouting{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileHttpApplicationRouting{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecAddonProfileHttpApplicationRoutingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecAddonProfileHttpApplicationRouting)(ptr) = KubernetesClusterSpecAddonProfileHttpApplicationRouting{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecAddonProfileHttpApplicationRouting

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileHttpApplicationRouting{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecAddonProfileHttpApplicationRouting)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecAddonProfileHttpApplicationRouting)(ptr) = KubernetesClusterSpecAddonProfileHttpApplicationRouting{}
			}
		} else {
			*(*KubernetesClusterSpecAddonProfileHttpApplicationRouting)(ptr) = KubernetesClusterSpecAddonProfileHttpApplicationRouting{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecAddonProfileHttpApplicationRouting

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileHttpApplicationRouting{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecAddonProfileHttpApplicationRouting)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecAddonProfileHttpApplicationRouting)(ptr) = KubernetesClusterSpecAddonProfileHttpApplicationRouting{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecAddonProfileHttpApplicationRouting", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecAddonProfileIngressApplicationGatewayCodec struct {
}

func (KubernetesClusterSpecAddonProfileIngressApplicationGatewayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecAddonProfileIngressApplicationGateway)(ptr) == nil
}

func (KubernetesClusterSpecAddonProfileIngressApplicationGatewayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecAddonProfileIngressApplicationGateway)(ptr)
	var objs []KubernetesClusterSpecAddonProfileIngressApplicationGateway
	if obj != nil {
		objs = []KubernetesClusterSpecAddonProfileIngressApplicationGateway{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileIngressApplicationGateway{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecAddonProfileIngressApplicationGatewayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecAddonProfileIngressApplicationGateway)(ptr) = KubernetesClusterSpecAddonProfileIngressApplicationGateway{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecAddonProfileIngressApplicationGateway

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileIngressApplicationGateway{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecAddonProfileIngressApplicationGateway)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecAddonProfileIngressApplicationGateway)(ptr) = KubernetesClusterSpecAddonProfileIngressApplicationGateway{}
			}
		} else {
			*(*KubernetesClusterSpecAddonProfileIngressApplicationGateway)(ptr) = KubernetesClusterSpecAddonProfileIngressApplicationGateway{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecAddonProfileIngressApplicationGateway

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileIngressApplicationGateway{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecAddonProfileIngressApplicationGateway)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecAddonProfileIngressApplicationGateway)(ptr) = KubernetesClusterSpecAddonProfileIngressApplicationGateway{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecAddonProfileIngressApplicationGateway", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecAddonProfileKubeDashboardCodec struct {
}

func (KubernetesClusterSpecAddonProfileKubeDashboardCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecAddonProfileKubeDashboard)(ptr) == nil
}

func (KubernetesClusterSpecAddonProfileKubeDashboardCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecAddonProfileKubeDashboard)(ptr)
	var objs []KubernetesClusterSpecAddonProfileKubeDashboard
	if obj != nil {
		objs = []KubernetesClusterSpecAddonProfileKubeDashboard{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileKubeDashboard{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecAddonProfileKubeDashboardCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecAddonProfileKubeDashboard)(ptr) = KubernetesClusterSpecAddonProfileKubeDashboard{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecAddonProfileKubeDashboard

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileKubeDashboard{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecAddonProfileKubeDashboard)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecAddonProfileKubeDashboard)(ptr) = KubernetesClusterSpecAddonProfileKubeDashboard{}
			}
		} else {
			*(*KubernetesClusterSpecAddonProfileKubeDashboard)(ptr) = KubernetesClusterSpecAddonProfileKubeDashboard{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecAddonProfileKubeDashboard

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileKubeDashboard{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecAddonProfileKubeDashboard)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecAddonProfileKubeDashboard)(ptr) = KubernetesClusterSpecAddonProfileKubeDashboard{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecAddonProfileKubeDashboard", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecAddonProfileOmsAgentCodec struct {
}

func (KubernetesClusterSpecAddonProfileOmsAgentCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecAddonProfileOmsAgent)(ptr) == nil
}

func (KubernetesClusterSpecAddonProfileOmsAgentCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecAddonProfileOmsAgent)(ptr)
	var objs []KubernetesClusterSpecAddonProfileOmsAgent
	if obj != nil {
		objs = []KubernetesClusterSpecAddonProfileOmsAgent{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileOmsAgent{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecAddonProfileOmsAgentCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecAddonProfileOmsAgent)(ptr) = KubernetesClusterSpecAddonProfileOmsAgent{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecAddonProfileOmsAgent

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileOmsAgent{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecAddonProfileOmsAgent)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecAddonProfileOmsAgent)(ptr) = KubernetesClusterSpecAddonProfileOmsAgent{}
			}
		} else {
			*(*KubernetesClusterSpecAddonProfileOmsAgent)(ptr) = KubernetesClusterSpecAddonProfileOmsAgent{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecAddonProfileOmsAgent

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileOmsAgent{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecAddonProfileOmsAgent)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecAddonProfileOmsAgent)(ptr) = KubernetesClusterSpecAddonProfileOmsAgent{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecAddonProfileOmsAgent", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecAutoScalerProfileCodec struct {
}

func (KubernetesClusterSpecAutoScalerProfileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecAutoScalerProfile)(ptr) == nil
}

func (KubernetesClusterSpecAutoScalerProfileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecAutoScalerProfile)(ptr)
	var objs []KubernetesClusterSpecAutoScalerProfile
	if obj != nil {
		objs = []KubernetesClusterSpecAutoScalerProfile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAutoScalerProfile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecAutoScalerProfileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecAutoScalerProfile)(ptr) = KubernetesClusterSpecAutoScalerProfile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecAutoScalerProfile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAutoScalerProfile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecAutoScalerProfile)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecAutoScalerProfile)(ptr) = KubernetesClusterSpecAutoScalerProfile{}
			}
		} else {
			*(*KubernetesClusterSpecAutoScalerProfile)(ptr) = KubernetesClusterSpecAutoScalerProfile{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecAutoScalerProfile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAutoScalerProfile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecAutoScalerProfile)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecAutoScalerProfile)(ptr) = KubernetesClusterSpecAutoScalerProfile{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecAutoScalerProfile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecDefaultNodePoolCodec struct {
}

func (KubernetesClusterSpecDefaultNodePoolCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecDefaultNodePool)(ptr) == nil
}

func (KubernetesClusterSpecDefaultNodePoolCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecDefaultNodePool)(ptr)
	var objs []KubernetesClusterSpecDefaultNodePool
	if obj != nil {
		objs = []KubernetesClusterSpecDefaultNodePool{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePool{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecDefaultNodePoolCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecDefaultNodePool)(ptr) = KubernetesClusterSpecDefaultNodePool{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecDefaultNodePool

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePool{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecDefaultNodePool)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecDefaultNodePool)(ptr) = KubernetesClusterSpecDefaultNodePool{}
			}
		} else {
			*(*KubernetesClusterSpecDefaultNodePool)(ptr) = KubernetesClusterSpecDefaultNodePool{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecDefaultNodePool

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePool{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecDefaultNodePool)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecDefaultNodePool)(ptr) = KubernetesClusterSpecDefaultNodePool{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecDefaultNodePool", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecDefaultNodePoolKubeletConfigCodec struct {
}

func (KubernetesClusterSpecDefaultNodePoolKubeletConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecDefaultNodePoolKubeletConfig)(ptr) == nil
}

func (KubernetesClusterSpecDefaultNodePoolKubeletConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecDefaultNodePoolKubeletConfig)(ptr)
	var objs []KubernetesClusterSpecDefaultNodePoolKubeletConfig
	if obj != nil {
		objs = []KubernetesClusterSpecDefaultNodePoolKubeletConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolKubeletConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecDefaultNodePoolKubeletConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecDefaultNodePoolKubeletConfig)(ptr) = KubernetesClusterSpecDefaultNodePoolKubeletConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecDefaultNodePoolKubeletConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolKubeletConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecDefaultNodePoolKubeletConfig)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecDefaultNodePoolKubeletConfig)(ptr) = KubernetesClusterSpecDefaultNodePoolKubeletConfig{}
			}
		} else {
			*(*KubernetesClusterSpecDefaultNodePoolKubeletConfig)(ptr) = KubernetesClusterSpecDefaultNodePoolKubeletConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecDefaultNodePoolKubeletConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolKubeletConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecDefaultNodePoolKubeletConfig)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecDefaultNodePoolKubeletConfig)(ptr) = KubernetesClusterSpecDefaultNodePoolKubeletConfig{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecDefaultNodePoolKubeletConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecDefaultNodePoolLinuxOsConfigCodec struct {
}

func (KubernetesClusterSpecDefaultNodePoolLinuxOsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecDefaultNodePoolLinuxOsConfig)(ptr) == nil
}

func (KubernetesClusterSpecDefaultNodePoolLinuxOsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecDefaultNodePoolLinuxOsConfig)(ptr)
	var objs []KubernetesClusterSpecDefaultNodePoolLinuxOsConfig
	if obj != nil {
		objs = []KubernetesClusterSpecDefaultNodePoolLinuxOsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolLinuxOsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecDefaultNodePoolLinuxOsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecDefaultNodePoolLinuxOsConfig)(ptr) = KubernetesClusterSpecDefaultNodePoolLinuxOsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecDefaultNodePoolLinuxOsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolLinuxOsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecDefaultNodePoolLinuxOsConfig)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecDefaultNodePoolLinuxOsConfig)(ptr) = KubernetesClusterSpecDefaultNodePoolLinuxOsConfig{}
			}
		} else {
			*(*KubernetesClusterSpecDefaultNodePoolLinuxOsConfig)(ptr) = KubernetesClusterSpecDefaultNodePoolLinuxOsConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecDefaultNodePoolLinuxOsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolLinuxOsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecDefaultNodePoolLinuxOsConfig)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecDefaultNodePoolLinuxOsConfig)(ptr) = KubernetesClusterSpecDefaultNodePoolLinuxOsConfig{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecDefaultNodePoolLinuxOsConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfigCodec struct {
}

func (KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig)(ptr) == nil
}

func (KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig)(ptr)
	var objs []KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig
	if obj != nil {
		objs = []KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig)(ptr) = KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig)(ptr) = KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig{}
			}
		} else {
			*(*KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig)(ptr) = KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig)(ptr) = KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecDefaultNodePoolLinuxOsConfigSysctlConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecDefaultNodePoolUpgradeSettingsCodec struct {
}

func (KubernetesClusterSpecDefaultNodePoolUpgradeSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecDefaultNodePoolUpgradeSettings)(ptr) == nil
}

func (KubernetesClusterSpecDefaultNodePoolUpgradeSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecDefaultNodePoolUpgradeSettings)(ptr)
	var objs []KubernetesClusterSpecDefaultNodePoolUpgradeSettings
	if obj != nil {
		objs = []KubernetesClusterSpecDefaultNodePoolUpgradeSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolUpgradeSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecDefaultNodePoolUpgradeSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecDefaultNodePoolUpgradeSettings)(ptr) = KubernetesClusterSpecDefaultNodePoolUpgradeSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecDefaultNodePoolUpgradeSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolUpgradeSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecDefaultNodePoolUpgradeSettings)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecDefaultNodePoolUpgradeSettings)(ptr) = KubernetesClusterSpecDefaultNodePoolUpgradeSettings{}
			}
		} else {
			*(*KubernetesClusterSpecDefaultNodePoolUpgradeSettings)(ptr) = KubernetesClusterSpecDefaultNodePoolUpgradeSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecDefaultNodePoolUpgradeSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolUpgradeSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecDefaultNodePoolUpgradeSettings)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecDefaultNodePoolUpgradeSettings)(ptr) = KubernetesClusterSpecDefaultNodePoolUpgradeSettings{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecDefaultNodePoolUpgradeSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecIdentityCodec struct {
}

func (KubernetesClusterSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecIdentity)(ptr) == nil
}

func (KubernetesClusterSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecIdentity)(ptr)
	var objs []KubernetesClusterSpecIdentity
	if obj != nil {
		objs = []KubernetesClusterSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecIdentity)(ptr) = KubernetesClusterSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecIdentity)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecIdentity)(ptr) = KubernetesClusterSpecIdentity{}
			}
		} else {
			*(*KubernetesClusterSpecIdentity)(ptr) = KubernetesClusterSpecIdentity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecIdentity)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecIdentity)(ptr) = KubernetesClusterSpecIdentity{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecKubeletIdentityCodec struct {
}

func (KubernetesClusterSpecKubeletIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecKubeletIdentity)(ptr) == nil
}

func (KubernetesClusterSpecKubeletIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecKubeletIdentity)(ptr)
	var objs []KubernetesClusterSpecKubeletIdentity
	if obj != nil {
		objs = []KubernetesClusterSpecKubeletIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecKubeletIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecKubeletIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecKubeletIdentity)(ptr) = KubernetesClusterSpecKubeletIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecKubeletIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecKubeletIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecKubeletIdentity)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecKubeletIdentity)(ptr) = KubernetesClusterSpecKubeletIdentity{}
			}
		} else {
			*(*KubernetesClusterSpecKubeletIdentity)(ptr) = KubernetesClusterSpecKubeletIdentity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecKubeletIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecKubeletIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecKubeletIdentity)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecKubeletIdentity)(ptr) = KubernetesClusterSpecKubeletIdentity{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecKubeletIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecLinuxProfileCodec struct {
}

func (KubernetesClusterSpecLinuxProfileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecLinuxProfile)(ptr) == nil
}

func (KubernetesClusterSpecLinuxProfileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecLinuxProfile)(ptr)
	var objs []KubernetesClusterSpecLinuxProfile
	if obj != nil {
		objs = []KubernetesClusterSpecLinuxProfile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecLinuxProfile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecLinuxProfileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecLinuxProfile)(ptr) = KubernetesClusterSpecLinuxProfile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecLinuxProfile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecLinuxProfile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecLinuxProfile)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecLinuxProfile)(ptr) = KubernetesClusterSpecLinuxProfile{}
			}
		} else {
			*(*KubernetesClusterSpecLinuxProfile)(ptr) = KubernetesClusterSpecLinuxProfile{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecLinuxProfile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecLinuxProfile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecLinuxProfile)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecLinuxProfile)(ptr) = KubernetesClusterSpecLinuxProfile{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecLinuxProfile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecLinuxProfileSshKeyCodec struct {
}

func (KubernetesClusterSpecLinuxProfileSshKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecLinuxProfileSshKey)(ptr) == nil
}

func (KubernetesClusterSpecLinuxProfileSshKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecLinuxProfileSshKey)(ptr)
	var objs []KubernetesClusterSpecLinuxProfileSshKey
	if obj != nil {
		objs = []KubernetesClusterSpecLinuxProfileSshKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecLinuxProfileSshKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecLinuxProfileSshKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecLinuxProfileSshKey)(ptr) = KubernetesClusterSpecLinuxProfileSshKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecLinuxProfileSshKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecLinuxProfileSshKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecLinuxProfileSshKey)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecLinuxProfileSshKey)(ptr) = KubernetesClusterSpecLinuxProfileSshKey{}
			}
		} else {
			*(*KubernetesClusterSpecLinuxProfileSshKey)(ptr) = KubernetesClusterSpecLinuxProfileSshKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecLinuxProfileSshKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecLinuxProfileSshKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecLinuxProfileSshKey)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecLinuxProfileSshKey)(ptr) = KubernetesClusterSpecLinuxProfileSshKey{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecLinuxProfileSshKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecNetworkProfileCodec struct {
}

func (KubernetesClusterSpecNetworkProfileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecNetworkProfile)(ptr) == nil
}

func (KubernetesClusterSpecNetworkProfileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecNetworkProfile)(ptr)
	var objs []KubernetesClusterSpecNetworkProfile
	if obj != nil {
		objs = []KubernetesClusterSpecNetworkProfile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecNetworkProfile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecNetworkProfileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecNetworkProfile)(ptr) = KubernetesClusterSpecNetworkProfile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecNetworkProfile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecNetworkProfile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecNetworkProfile)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecNetworkProfile)(ptr) = KubernetesClusterSpecNetworkProfile{}
			}
		} else {
			*(*KubernetesClusterSpecNetworkProfile)(ptr) = KubernetesClusterSpecNetworkProfile{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecNetworkProfile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecNetworkProfile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecNetworkProfile)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecNetworkProfile)(ptr) = KubernetesClusterSpecNetworkProfile{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecNetworkProfile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecNetworkProfileLoadBalancerProfileCodec struct {
}

func (KubernetesClusterSpecNetworkProfileLoadBalancerProfileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecNetworkProfileLoadBalancerProfile)(ptr) == nil
}

func (KubernetesClusterSpecNetworkProfileLoadBalancerProfileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecNetworkProfileLoadBalancerProfile)(ptr)
	var objs []KubernetesClusterSpecNetworkProfileLoadBalancerProfile
	if obj != nil {
		objs = []KubernetesClusterSpecNetworkProfileLoadBalancerProfile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecNetworkProfileLoadBalancerProfile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecNetworkProfileLoadBalancerProfileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecNetworkProfileLoadBalancerProfile)(ptr) = KubernetesClusterSpecNetworkProfileLoadBalancerProfile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecNetworkProfileLoadBalancerProfile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecNetworkProfileLoadBalancerProfile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecNetworkProfileLoadBalancerProfile)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecNetworkProfileLoadBalancerProfile)(ptr) = KubernetesClusterSpecNetworkProfileLoadBalancerProfile{}
			}
		} else {
			*(*KubernetesClusterSpecNetworkProfileLoadBalancerProfile)(ptr) = KubernetesClusterSpecNetworkProfileLoadBalancerProfile{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecNetworkProfileLoadBalancerProfile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecNetworkProfileLoadBalancerProfile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecNetworkProfileLoadBalancerProfile)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecNetworkProfileLoadBalancerProfile)(ptr) = KubernetesClusterSpecNetworkProfileLoadBalancerProfile{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecNetworkProfileLoadBalancerProfile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecRoleBasedAccessControlCodec struct {
}

func (KubernetesClusterSpecRoleBasedAccessControlCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecRoleBasedAccessControl)(ptr) == nil
}

func (KubernetesClusterSpecRoleBasedAccessControlCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecRoleBasedAccessControl)(ptr)
	var objs []KubernetesClusterSpecRoleBasedAccessControl
	if obj != nil {
		objs = []KubernetesClusterSpecRoleBasedAccessControl{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecRoleBasedAccessControl{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecRoleBasedAccessControlCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecRoleBasedAccessControl)(ptr) = KubernetesClusterSpecRoleBasedAccessControl{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecRoleBasedAccessControl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecRoleBasedAccessControl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecRoleBasedAccessControl)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecRoleBasedAccessControl)(ptr) = KubernetesClusterSpecRoleBasedAccessControl{}
			}
		} else {
			*(*KubernetesClusterSpecRoleBasedAccessControl)(ptr) = KubernetesClusterSpecRoleBasedAccessControl{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecRoleBasedAccessControl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecRoleBasedAccessControl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecRoleBasedAccessControl)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecRoleBasedAccessControl)(ptr) = KubernetesClusterSpecRoleBasedAccessControl{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecRoleBasedAccessControl", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectoryCodec struct {
}

func (KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectoryCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory)(ptr) == nil
}

func (KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectoryCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory)(ptr)
	var objs []KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory
	if obj != nil {
		objs = []KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectoryCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory)(ptr) = KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory)(ptr) = KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory{}
			}
		} else {
			*(*KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory)(ptr) = KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory)(ptr) = KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecServicePrincipalCodec struct {
}

func (KubernetesClusterSpecServicePrincipalCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecServicePrincipal)(ptr) == nil
}

func (KubernetesClusterSpecServicePrincipalCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecServicePrincipal)(ptr)
	var objs []KubernetesClusterSpecServicePrincipal
	if obj != nil {
		objs = []KubernetesClusterSpecServicePrincipal{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecServicePrincipal{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecServicePrincipalCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecServicePrincipal)(ptr) = KubernetesClusterSpecServicePrincipal{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecServicePrincipal

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecServicePrincipal{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecServicePrincipal)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecServicePrincipal)(ptr) = KubernetesClusterSpecServicePrincipal{}
			}
		} else {
			*(*KubernetesClusterSpecServicePrincipal)(ptr) = KubernetesClusterSpecServicePrincipal{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecServicePrincipal

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecServicePrincipal{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecServicePrincipal)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecServicePrincipal)(ptr) = KubernetesClusterSpecServicePrincipal{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecServicePrincipal", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecWindowsProfileCodec struct {
}

func (KubernetesClusterSpecWindowsProfileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecWindowsProfile)(ptr) == nil
}

func (KubernetesClusterSpecWindowsProfileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecWindowsProfile)(ptr)
	var objs []KubernetesClusterSpecWindowsProfile
	if obj != nil {
		objs = []KubernetesClusterSpecWindowsProfile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecWindowsProfile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecWindowsProfileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecWindowsProfile)(ptr) = KubernetesClusterSpecWindowsProfile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecWindowsProfile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecWindowsProfile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecWindowsProfile)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecWindowsProfile)(ptr) = KubernetesClusterSpecWindowsProfile{}
			}
		} else {
			*(*KubernetesClusterSpecWindowsProfile)(ptr) = KubernetesClusterSpecWindowsProfile{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj KubernetesClusterSpecWindowsProfile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecWindowsProfile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*KubernetesClusterSpecWindowsProfile)(ptr) = obj
		} else {
			*(*KubernetesClusterSpecWindowsProfile)(ptr) = KubernetesClusterSpecWindowsProfile{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecWindowsProfile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecKubeletConfigCodec struct {
}

func (NodePoolSpecKubeletConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecKubeletConfig)(ptr) == nil
}

func (NodePoolSpecKubeletConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecKubeletConfig)(ptr)
	var objs []NodePoolSpecKubeletConfig
	if obj != nil {
		objs = []NodePoolSpecKubeletConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecKubeletConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecKubeletConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecKubeletConfig)(ptr) = NodePoolSpecKubeletConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecKubeletConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecKubeletConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecKubeletConfig)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecKubeletConfig)(ptr) = NodePoolSpecKubeletConfig{}
			}
		} else {
			*(*NodePoolSpecKubeletConfig)(ptr) = NodePoolSpecKubeletConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NodePoolSpecKubeletConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecKubeletConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NodePoolSpecKubeletConfig)(ptr) = obj
		} else {
			*(*NodePoolSpecKubeletConfig)(ptr) = NodePoolSpecKubeletConfig{}
		}
	default:
		iter.ReportError("decode NodePoolSpecKubeletConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecLinuxOsConfigCodec struct {
}

func (NodePoolSpecLinuxOsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecLinuxOsConfig)(ptr) == nil
}

func (NodePoolSpecLinuxOsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecLinuxOsConfig)(ptr)
	var objs []NodePoolSpecLinuxOsConfig
	if obj != nil {
		objs = []NodePoolSpecLinuxOsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecLinuxOsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecLinuxOsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecLinuxOsConfig)(ptr) = NodePoolSpecLinuxOsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecLinuxOsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecLinuxOsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecLinuxOsConfig)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecLinuxOsConfig)(ptr) = NodePoolSpecLinuxOsConfig{}
			}
		} else {
			*(*NodePoolSpecLinuxOsConfig)(ptr) = NodePoolSpecLinuxOsConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NodePoolSpecLinuxOsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecLinuxOsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NodePoolSpecLinuxOsConfig)(ptr) = obj
		} else {
			*(*NodePoolSpecLinuxOsConfig)(ptr) = NodePoolSpecLinuxOsConfig{}
		}
	default:
		iter.ReportError("decode NodePoolSpecLinuxOsConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecLinuxOsConfigSysctlConfigCodec struct {
}

func (NodePoolSpecLinuxOsConfigSysctlConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecLinuxOsConfigSysctlConfig)(ptr) == nil
}

func (NodePoolSpecLinuxOsConfigSysctlConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecLinuxOsConfigSysctlConfig)(ptr)
	var objs []NodePoolSpecLinuxOsConfigSysctlConfig
	if obj != nil {
		objs = []NodePoolSpecLinuxOsConfigSysctlConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecLinuxOsConfigSysctlConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecLinuxOsConfigSysctlConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecLinuxOsConfigSysctlConfig)(ptr) = NodePoolSpecLinuxOsConfigSysctlConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecLinuxOsConfigSysctlConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecLinuxOsConfigSysctlConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecLinuxOsConfigSysctlConfig)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecLinuxOsConfigSysctlConfig)(ptr) = NodePoolSpecLinuxOsConfigSysctlConfig{}
			}
		} else {
			*(*NodePoolSpecLinuxOsConfigSysctlConfig)(ptr) = NodePoolSpecLinuxOsConfigSysctlConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NodePoolSpecLinuxOsConfigSysctlConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecLinuxOsConfigSysctlConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NodePoolSpecLinuxOsConfigSysctlConfig)(ptr) = obj
		} else {
			*(*NodePoolSpecLinuxOsConfigSysctlConfig)(ptr) = NodePoolSpecLinuxOsConfigSysctlConfig{}
		}
	default:
		iter.ReportError("decode NodePoolSpecLinuxOsConfigSysctlConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecUpgradeSettingsCodec struct {
}

func (NodePoolSpecUpgradeSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecUpgradeSettings)(ptr) == nil
}

func (NodePoolSpecUpgradeSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecUpgradeSettings)(ptr)
	var objs []NodePoolSpecUpgradeSettings
	if obj != nil {
		objs = []NodePoolSpecUpgradeSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecUpgradeSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecUpgradeSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecUpgradeSettings)(ptr) = NodePoolSpecUpgradeSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecUpgradeSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecUpgradeSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecUpgradeSettings)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecUpgradeSettings)(ptr) = NodePoolSpecUpgradeSettings{}
			}
		} else {
			*(*NodePoolSpecUpgradeSettings)(ptr) = NodePoolSpecUpgradeSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NodePoolSpecUpgradeSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecUpgradeSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NodePoolSpecUpgradeSettings)(ptr) = obj
		} else {
			*(*NodePoolSpecUpgradeSettings)(ptr) = NodePoolSpecUpgradeSettings{}
		}
	default:
		iter.ReportError("decode NodePoolSpecUpgradeSettings", "unexpected JSON type")
	}
}

/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecGithubConfiguration{}).Type1()):                                                     FactorySpecGithubConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecIdentity{}).Type1()):                                                                FactorySpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecVstsConfiguration{}).Type1()):                                                       FactorySpecVstsConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryCustomDatasetSpecLinkedService{}).Type1()):                                              FactoryCustomDatasetSpecLinkedServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSinkDataset{}).Type1()):                                                     FactoryDataFlowSpecSinkDatasetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSinkLinkedService{}).Type1()):                                               FactoryDataFlowSpecSinkLinkedServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSinkSchemaLinkedService{}).Type1()):                                         FactoryDataFlowSpecSinkSchemaLinkedServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSourceDataset{}).Type1()):                                                   FactoryDataFlowSpecSourceDatasetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSourceLinkedService{}).Type1()):                                             FactoryDataFlowSpecSourceLinkedServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSourceSchemaLinkedService{}).Type1()):                                       FactoryDataFlowSpecSourceSchemaLinkedServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetBinarySpecAzureBlobStorageLocation{}).Type1()):                                   FactoryDatasetBinarySpecAzureBlobStorageLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetBinarySpecCompression{}).Type1()):                                                FactoryDatasetBinarySpecCompressionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetBinarySpecHttpServerLocation{}).Type1()):                                         FactoryDatasetBinarySpecHttpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetBinarySpecSftpServerLocation{}).Type1()):                                         FactoryDatasetBinarySpecSftpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobFsLocation{}).Type1()):                                 FactoryDatasetDelimitedTextSpecAzureBlobFsLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}).Type1()):                            FactoryDatasetDelimitedTextSpecAzureBlobStorageLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecHttpServerLocation{}).Type1()):                                  FactoryDatasetDelimitedTextSpecHttpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecAzureBlobStorageLocation{}).Type1()):                                     FactoryDatasetJSONSpecAzureBlobStorageLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecHttpServerLocation{}).Type1()):                                           FactoryDatasetJSONSpecHttpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecAzureBlobStorageLocation{}).Type1()):                                  FactoryDatasetParquetSpecAzureBlobStorageLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecHttpServerLocation{}).Type1()):                                        FactoryDatasetParquetSpecHttpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}).Type1()):                                  FactoryIntegrationRuntimeAzureSsisSpecCatalogInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}).Type1()):                            FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScriptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup{}).Type1()):                           FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword{}).Type1()): FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense{}).Type1()):   FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicenseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecProxy{}).Type1()):                                        FactoryIntegrationRuntimeAzureSsisSpecProxyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}).Type1()):                              FactoryIntegrationRuntimeAzureSsisSpecVnetIntegrationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCatalogInfo{}).Type1()):                                    FactoryIntegrationRuntimeManagedSpecCatalogInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}).Type1()):                              FactoryIntegrationRuntimeManagedSpecCustomSetupScriptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecVnetIntegration{}).Type1()):                                FactoryIntegrationRuntimeManagedSpecVnetIntegrationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedCustomServiceSpecIntegrationRuntime{}).Type1()):                                   FactoryLinkedCustomServiceSpecIntegrationRuntimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken{}).Type1()):                           FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasTokenCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecInstancePool{}).Type1()):                                FactoryLinkedServiceAzureDatabricksSpecInstancePoolCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}).Type1()):                            FactoryLinkedServiceAzureDatabricksSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}).Type1()):                            FactoryLinkedServiceAzureDatabricksSpecNewClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}).Type1()):                           FactoryLinkedServiceAzureFileStorageSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureFunctionSpecKeyVaultKey{}).Type1()):                                   FactoryLinkedServiceAzureFunctionSpecKeyVaultKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString{}).Type1()):                   FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionStringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}).Type1()):                           FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceOdataSpecBasicAuthentication{}).Type1()):                                   FactoryLinkedServiceOdataSpecBasicAuthenticationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceOdbcSpecBasicAuthentication{}).Type1()):                                    FactoryLinkedServiceOdbcSpecBasicAuthenticationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}).Type1()):                                  FactoryLinkedServiceSnowflakeSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString{}).Type1()):                          FactoryLinkedServiceSQLServerSpecKeyVaultConnectionStringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}).Type1()):                                  FactoryLinkedServiceSQLServerSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSynapseSpecKeyVaultPassword{}).Type1()):                                    FactoryLinkedServiceSynapseSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryTriggerScheduleSpecSchedule{}).Type1()):                                                 FactoryTriggerScheduleSpecScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryTriggerTumblingWindowSpecPipeline{}).Type1()):                                           FactoryTriggerTumblingWindowSpecPipelineCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryTriggerTumblingWindowSpecRetry{}).Type1()):                                              FactoryTriggerTumblingWindowSpecRetryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LakeStoreSpecIdentity{}).Type1()):                                                              LakeStoreSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupPolicyDiskSpecRetentionRuleCriteria{}).Type1()):                                ProtectionBackupPolicyDiskSpecRetentionRuleCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria{}).Type1()):                          ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupVaultSpecIdentity{}).Type1()):                                                  ProtectionBackupVaultSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ShareSpecSnapshotSchedule{}).Type1()):                                                          ShareSpecSnapshotScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ShareAccountSpecIdentity{}).Type1()):                                                           ShareAccountSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ShareDatasetBlobStorageSpecStorageAccount{}).Type1()):                                          ShareDatasetBlobStorageSpecStorageAccountCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecGithubConfiguration{}).Type1()):                                                     FactorySpecGithubConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecIdentity{}).Type1()):                                                                FactorySpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecVstsConfiguration{}).Type1()):                                                       FactorySpecVstsConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryCustomDatasetSpecLinkedService{}).Type1()):                                              FactoryCustomDatasetSpecLinkedServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSinkDataset{}).Type1()):                                                     FactoryDataFlowSpecSinkDatasetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSinkLinkedService{}).Type1()):                                               FactoryDataFlowSpecSinkLinkedServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSinkSchemaLinkedService{}).Type1()):                                         FactoryDataFlowSpecSinkSchemaLinkedServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSourceDataset{}).Type1()):                                                   FactoryDataFlowSpecSourceDatasetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSourceLinkedService{}).Type1()):                                             FactoryDataFlowSpecSourceLinkedServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSourceSchemaLinkedService{}).Type1()):                                       FactoryDataFlowSpecSourceSchemaLinkedServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetBinarySpecAzureBlobStorageLocation{}).Type1()):                                   FactoryDatasetBinarySpecAzureBlobStorageLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetBinarySpecCompression{}).Type1()):                                                FactoryDatasetBinarySpecCompressionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetBinarySpecHttpServerLocation{}).Type1()):                                         FactoryDatasetBinarySpecHttpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetBinarySpecSftpServerLocation{}).Type1()):                                         FactoryDatasetBinarySpecSftpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobFsLocation{}).Type1()):                                 FactoryDatasetDelimitedTextSpecAzureBlobFsLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}).Type1()):                            FactoryDatasetDelimitedTextSpecAzureBlobStorageLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecHttpServerLocation{}).Type1()):                                  FactoryDatasetDelimitedTextSpecHttpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecAzureBlobStorageLocation{}).Type1()):                                     FactoryDatasetJSONSpecAzureBlobStorageLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecHttpServerLocation{}).Type1()):                                           FactoryDatasetJSONSpecHttpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecAzureBlobStorageLocation{}).Type1()):                                  FactoryDatasetParquetSpecAzureBlobStorageLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecHttpServerLocation{}).Type1()):                                        FactoryDatasetParquetSpecHttpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}).Type1()):                                  FactoryIntegrationRuntimeAzureSsisSpecCatalogInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}).Type1()):                            FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScriptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup{}).Type1()):                           FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword{}).Type1()): FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense{}).Type1()):   FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicenseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecProxy{}).Type1()):                                        FactoryIntegrationRuntimeAzureSsisSpecProxyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}).Type1()):                              FactoryIntegrationRuntimeAzureSsisSpecVnetIntegrationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCatalogInfo{}).Type1()):                                    FactoryIntegrationRuntimeManagedSpecCatalogInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}).Type1()):                              FactoryIntegrationRuntimeManagedSpecCustomSetupScriptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecVnetIntegration{}).Type1()):                                FactoryIntegrationRuntimeManagedSpecVnetIntegrationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedCustomServiceSpecIntegrationRuntime{}).Type1()):                                   FactoryLinkedCustomServiceSpecIntegrationRuntimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken{}).Type1()):                           FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasTokenCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecInstancePool{}).Type1()):                                FactoryLinkedServiceAzureDatabricksSpecInstancePoolCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}).Type1()):                            FactoryLinkedServiceAzureDatabricksSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}).Type1()):                            FactoryLinkedServiceAzureDatabricksSpecNewClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}).Type1()):                           FactoryLinkedServiceAzureFileStorageSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureFunctionSpecKeyVaultKey{}).Type1()):                                   FactoryLinkedServiceAzureFunctionSpecKeyVaultKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString{}).Type1()):                   FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionStringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}).Type1()):                           FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceOdataSpecBasicAuthentication{}).Type1()):                                   FactoryLinkedServiceOdataSpecBasicAuthenticationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceOdbcSpecBasicAuthentication{}).Type1()):                                    FactoryLinkedServiceOdbcSpecBasicAuthenticationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}).Type1()):                                  FactoryLinkedServiceSnowflakeSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString{}).Type1()):                          FactoryLinkedServiceSQLServerSpecKeyVaultConnectionStringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}).Type1()):                                  FactoryLinkedServiceSQLServerSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSynapseSpecKeyVaultPassword{}).Type1()):                                    FactoryLinkedServiceSynapseSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryTriggerScheduleSpecSchedule{}).Type1()):                                                 FactoryTriggerScheduleSpecScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryTriggerTumblingWindowSpecPipeline{}).Type1()):                                           FactoryTriggerTumblingWindowSpecPipelineCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryTriggerTumblingWindowSpecRetry{}).Type1()):                                              FactoryTriggerTumblingWindowSpecRetryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LakeStoreSpecIdentity{}).Type1()):                                                              LakeStoreSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupPolicyDiskSpecRetentionRuleCriteria{}).Type1()):                                ProtectionBackupPolicyDiskSpecRetentionRuleCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria{}).Type1()):                          ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupVaultSpecIdentity{}).Type1()):                                                  ProtectionBackupVaultSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ShareSpecSnapshotSchedule{}).Type1()):                                                          ShareSpecSnapshotScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ShareAccountSpecIdentity{}).Type1()):                                                           ShareAccountSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ShareDatasetBlobStorageSpecStorageAccount{}).Type1()):                                          ShareDatasetBlobStorageSpecStorageAccountCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type FactorySpecGithubConfigurationCodec struct {
}

func (FactorySpecGithubConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactorySpecGithubConfiguration)(ptr) == nil
}

func (FactorySpecGithubConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactorySpecGithubConfiguration)(ptr)
	var objs []FactorySpecGithubConfiguration
	if obj != nil {
		objs = []FactorySpecGithubConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecGithubConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactorySpecGithubConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactorySpecGithubConfiguration)(ptr) = FactorySpecGithubConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactorySpecGithubConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecGithubConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactorySpecGithubConfiguration)(ptr) = objs[0]
			} else {
				*(*FactorySpecGithubConfiguration)(ptr) = FactorySpecGithubConfiguration{}
			}
		} else {
			*(*FactorySpecGithubConfiguration)(ptr) = FactorySpecGithubConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactorySpecGithubConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecGithubConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactorySpecGithubConfiguration)(ptr) = obj
		} else {
			*(*FactorySpecGithubConfiguration)(ptr) = FactorySpecGithubConfiguration{}
		}
	default:
		iter.ReportError("decode FactorySpecGithubConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactorySpecIdentityCodec struct {
}

func (FactorySpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactorySpecIdentity)(ptr) == nil
}

func (FactorySpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactorySpecIdentity)(ptr)
	var objs []FactorySpecIdentity
	if obj != nil {
		objs = []FactorySpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactorySpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactorySpecIdentity)(ptr) = FactorySpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactorySpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactorySpecIdentity)(ptr) = objs[0]
			} else {
				*(*FactorySpecIdentity)(ptr) = FactorySpecIdentity{}
			}
		} else {
			*(*FactorySpecIdentity)(ptr) = FactorySpecIdentity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactorySpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactorySpecIdentity)(ptr) = obj
		} else {
			*(*FactorySpecIdentity)(ptr) = FactorySpecIdentity{}
		}
	default:
		iter.ReportError("decode FactorySpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactorySpecVstsConfigurationCodec struct {
}

func (FactorySpecVstsConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactorySpecVstsConfiguration)(ptr) == nil
}

func (FactorySpecVstsConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactorySpecVstsConfiguration)(ptr)
	var objs []FactorySpecVstsConfiguration
	if obj != nil {
		objs = []FactorySpecVstsConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecVstsConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactorySpecVstsConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactorySpecVstsConfiguration)(ptr) = FactorySpecVstsConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactorySpecVstsConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecVstsConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactorySpecVstsConfiguration)(ptr) = objs[0]
			} else {
				*(*FactorySpecVstsConfiguration)(ptr) = FactorySpecVstsConfiguration{}
			}
		} else {
			*(*FactorySpecVstsConfiguration)(ptr) = FactorySpecVstsConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactorySpecVstsConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecVstsConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactorySpecVstsConfiguration)(ptr) = obj
		} else {
			*(*FactorySpecVstsConfiguration)(ptr) = FactorySpecVstsConfiguration{}
		}
	default:
		iter.ReportError("decode FactorySpecVstsConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryCustomDatasetSpecLinkedServiceCodec struct {
}

func (FactoryCustomDatasetSpecLinkedServiceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryCustomDatasetSpecLinkedService)(ptr) == nil
}

func (FactoryCustomDatasetSpecLinkedServiceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryCustomDatasetSpecLinkedService)(ptr)
	var objs []FactoryCustomDatasetSpecLinkedService
	if obj != nil {
		objs = []FactoryCustomDatasetSpecLinkedService{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryCustomDatasetSpecLinkedService{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryCustomDatasetSpecLinkedServiceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryCustomDatasetSpecLinkedService)(ptr) = FactoryCustomDatasetSpecLinkedService{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryCustomDatasetSpecLinkedService

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryCustomDatasetSpecLinkedService{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryCustomDatasetSpecLinkedService)(ptr) = objs[0]
			} else {
				*(*FactoryCustomDatasetSpecLinkedService)(ptr) = FactoryCustomDatasetSpecLinkedService{}
			}
		} else {
			*(*FactoryCustomDatasetSpecLinkedService)(ptr) = FactoryCustomDatasetSpecLinkedService{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryCustomDatasetSpecLinkedService

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryCustomDatasetSpecLinkedService{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryCustomDatasetSpecLinkedService)(ptr) = obj
		} else {
			*(*FactoryCustomDatasetSpecLinkedService)(ptr) = FactoryCustomDatasetSpecLinkedService{}
		}
	default:
		iter.ReportError("decode FactoryCustomDatasetSpecLinkedService", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDataFlowSpecSinkDatasetCodec struct {
}

func (FactoryDataFlowSpecSinkDatasetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDataFlowSpecSinkDataset)(ptr) == nil
}

func (FactoryDataFlowSpecSinkDatasetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDataFlowSpecSinkDataset)(ptr)
	var objs []FactoryDataFlowSpecSinkDataset
	if obj != nil {
		objs = []FactoryDataFlowSpecSinkDataset{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSinkDataset{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDataFlowSpecSinkDatasetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDataFlowSpecSinkDataset)(ptr) = FactoryDataFlowSpecSinkDataset{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDataFlowSpecSinkDataset

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSinkDataset{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDataFlowSpecSinkDataset)(ptr) = objs[0]
			} else {
				*(*FactoryDataFlowSpecSinkDataset)(ptr) = FactoryDataFlowSpecSinkDataset{}
			}
		} else {
			*(*FactoryDataFlowSpecSinkDataset)(ptr) = FactoryDataFlowSpecSinkDataset{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDataFlowSpecSinkDataset

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSinkDataset{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDataFlowSpecSinkDataset)(ptr) = obj
		} else {
			*(*FactoryDataFlowSpecSinkDataset)(ptr) = FactoryDataFlowSpecSinkDataset{}
		}
	default:
		iter.ReportError("decode FactoryDataFlowSpecSinkDataset", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDataFlowSpecSinkLinkedServiceCodec struct {
}

func (FactoryDataFlowSpecSinkLinkedServiceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDataFlowSpecSinkLinkedService)(ptr) == nil
}

func (FactoryDataFlowSpecSinkLinkedServiceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDataFlowSpecSinkLinkedService)(ptr)
	var objs []FactoryDataFlowSpecSinkLinkedService
	if obj != nil {
		objs = []FactoryDataFlowSpecSinkLinkedService{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSinkLinkedService{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDataFlowSpecSinkLinkedServiceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDataFlowSpecSinkLinkedService)(ptr) = FactoryDataFlowSpecSinkLinkedService{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDataFlowSpecSinkLinkedService

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSinkLinkedService{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDataFlowSpecSinkLinkedService)(ptr) = objs[0]
			} else {
				*(*FactoryDataFlowSpecSinkLinkedService)(ptr) = FactoryDataFlowSpecSinkLinkedService{}
			}
		} else {
			*(*FactoryDataFlowSpecSinkLinkedService)(ptr) = FactoryDataFlowSpecSinkLinkedService{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDataFlowSpecSinkLinkedService

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSinkLinkedService{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDataFlowSpecSinkLinkedService)(ptr) = obj
		} else {
			*(*FactoryDataFlowSpecSinkLinkedService)(ptr) = FactoryDataFlowSpecSinkLinkedService{}
		}
	default:
		iter.ReportError("decode FactoryDataFlowSpecSinkLinkedService", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDataFlowSpecSinkSchemaLinkedServiceCodec struct {
}

func (FactoryDataFlowSpecSinkSchemaLinkedServiceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDataFlowSpecSinkSchemaLinkedService)(ptr) == nil
}

func (FactoryDataFlowSpecSinkSchemaLinkedServiceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDataFlowSpecSinkSchemaLinkedService)(ptr)
	var objs []FactoryDataFlowSpecSinkSchemaLinkedService
	if obj != nil {
		objs = []FactoryDataFlowSpecSinkSchemaLinkedService{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSinkSchemaLinkedService{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDataFlowSpecSinkSchemaLinkedServiceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDataFlowSpecSinkSchemaLinkedService)(ptr) = FactoryDataFlowSpecSinkSchemaLinkedService{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDataFlowSpecSinkSchemaLinkedService

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSinkSchemaLinkedService{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDataFlowSpecSinkSchemaLinkedService)(ptr) = objs[0]
			} else {
				*(*FactoryDataFlowSpecSinkSchemaLinkedService)(ptr) = FactoryDataFlowSpecSinkSchemaLinkedService{}
			}
		} else {
			*(*FactoryDataFlowSpecSinkSchemaLinkedService)(ptr) = FactoryDataFlowSpecSinkSchemaLinkedService{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDataFlowSpecSinkSchemaLinkedService

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSinkSchemaLinkedService{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDataFlowSpecSinkSchemaLinkedService)(ptr) = obj
		} else {
			*(*FactoryDataFlowSpecSinkSchemaLinkedService)(ptr) = FactoryDataFlowSpecSinkSchemaLinkedService{}
		}
	default:
		iter.ReportError("decode FactoryDataFlowSpecSinkSchemaLinkedService", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDataFlowSpecSourceDatasetCodec struct {
}

func (FactoryDataFlowSpecSourceDatasetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDataFlowSpecSourceDataset)(ptr) == nil
}

func (FactoryDataFlowSpecSourceDatasetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDataFlowSpecSourceDataset)(ptr)
	var objs []FactoryDataFlowSpecSourceDataset
	if obj != nil {
		objs = []FactoryDataFlowSpecSourceDataset{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSourceDataset{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDataFlowSpecSourceDatasetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDataFlowSpecSourceDataset)(ptr) = FactoryDataFlowSpecSourceDataset{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDataFlowSpecSourceDataset

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSourceDataset{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDataFlowSpecSourceDataset)(ptr) = objs[0]
			} else {
				*(*FactoryDataFlowSpecSourceDataset)(ptr) = FactoryDataFlowSpecSourceDataset{}
			}
		} else {
			*(*FactoryDataFlowSpecSourceDataset)(ptr) = FactoryDataFlowSpecSourceDataset{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDataFlowSpecSourceDataset

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSourceDataset{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDataFlowSpecSourceDataset)(ptr) = obj
		} else {
			*(*FactoryDataFlowSpecSourceDataset)(ptr) = FactoryDataFlowSpecSourceDataset{}
		}
	default:
		iter.ReportError("decode FactoryDataFlowSpecSourceDataset", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDataFlowSpecSourceLinkedServiceCodec struct {
}

func (FactoryDataFlowSpecSourceLinkedServiceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDataFlowSpecSourceLinkedService)(ptr) == nil
}

func (FactoryDataFlowSpecSourceLinkedServiceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDataFlowSpecSourceLinkedService)(ptr)
	var objs []FactoryDataFlowSpecSourceLinkedService
	if obj != nil {
		objs = []FactoryDataFlowSpecSourceLinkedService{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSourceLinkedService{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDataFlowSpecSourceLinkedServiceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDataFlowSpecSourceLinkedService)(ptr) = FactoryDataFlowSpecSourceLinkedService{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDataFlowSpecSourceLinkedService

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSourceLinkedService{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDataFlowSpecSourceLinkedService)(ptr) = objs[0]
			} else {
				*(*FactoryDataFlowSpecSourceLinkedService)(ptr) = FactoryDataFlowSpecSourceLinkedService{}
			}
		} else {
			*(*FactoryDataFlowSpecSourceLinkedService)(ptr) = FactoryDataFlowSpecSourceLinkedService{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDataFlowSpecSourceLinkedService

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSourceLinkedService{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDataFlowSpecSourceLinkedService)(ptr) = obj
		} else {
			*(*FactoryDataFlowSpecSourceLinkedService)(ptr) = FactoryDataFlowSpecSourceLinkedService{}
		}
	default:
		iter.ReportError("decode FactoryDataFlowSpecSourceLinkedService", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDataFlowSpecSourceSchemaLinkedServiceCodec struct {
}

func (FactoryDataFlowSpecSourceSchemaLinkedServiceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDataFlowSpecSourceSchemaLinkedService)(ptr) == nil
}

func (FactoryDataFlowSpecSourceSchemaLinkedServiceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDataFlowSpecSourceSchemaLinkedService)(ptr)
	var objs []FactoryDataFlowSpecSourceSchemaLinkedService
	if obj != nil {
		objs = []FactoryDataFlowSpecSourceSchemaLinkedService{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSourceSchemaLinkedService{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDataFlowSpecSourceSchemaLinkedServiceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDataFlowSpecSourceSchemaLinkedService)(ptr) = FactoryDataFlowSpecSourceSchemaLinkedService{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDataFlowSpecSourceSchemaLinkedService

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSourceSchemaLinkedService{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDataFlowSpecSourceSchemaLinkedService)(ptr) = objs[0]
			} else {
				*(*FactoryDataFlowSpecSourceSchemaLinkedService)(ptr) = FactoryDataFlowSpecSourceSchemaLinkedService{}
			}
		} else {
			*(*FactoryDataFlowSpecSourceSchemaLinkedService)(ptr) = FactoryDataFlowSpecSourceSchemaLinkedService{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDataFlowSpecSourceSchemaLinkedService

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDataFlowSpecSourceSchemaLinkedService{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDataFlowSpecSourceSchemaLinkedService)(ptr) = obj
		} else {
			*(*FactoryDataFlowSpecSourceSchemaLinkedService)(ptr) = FactoryDataFlowSpecSourceSchemaLinkedService{}
		}
	default:
		iter.ReportError("decode FactoryDataFlowSpecSourceSchemaLinkedService", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetBinarySpecAzureBlobStorageLocationCodec struct {
}

func (FactoryDatasetBinarySpecAzureBlobStorageLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetBinarySpecAzureBlobStorageLocation)(ptr) == nil
}

func (FactoryDatasetBinarySpecAzureBlobStorageLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetBinarySpecAzureBlobStorageLocation)(ptr)
	var objs []FactoryDatasetBinarySpecAzureBlobStorageLocation
	if obj != nil {
		objs = []FactoryDatasetBinarySpecAzureBlobStorageLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetBinarySpecAzureBlobStorageLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetBinarySpecAzureBlobStorageLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetBinarySpecAzureBlobStorageLocation)(ptr) = FactoryDatasetBinarySpecAzureBlobStorageLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetBinarySpecAzureBlobStorageLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetBinarySpecAzureBlobStorageLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetBinarySpecAzureBlobStorageLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetBinarySpecAzureBlobStorageLocation)(ptr) = FactoryDatasetBinarySpecAzureBlobStorageLocation{}
			}
		} else {
			*(*FactoryDatasetBinarySpecAzureBlobStorageLocation)(ptr) = FactoryDatasetBinarySpecAzureBlobStorageLocation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDatasetBinarySpecAzureBlobStorageLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetBinarySpecAzureBlobStorageLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDatasetBinarySpecAzureBlobStorageLocation)(ptr) = obj
		} else {
			*(*FactoryDatasetBinarySpecAzureBlobStorageLocation)(ptr) = FactoryDatasetBinarySpecAzureBlobStorageLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetBinarySpecAzureBlobStorageLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetBinarySpecCompressionCodec struct {
}

func (FactoryDatasetBinarySpecCompressionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetBinarySpecCompression)(ptr) == nil
}

func (FactoryDatasetBinarySpecCompressionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetBinarySpecCompression)(ptr)
	var objs []FactoryDatasetBinarySpecCompression
	if obj != nil {
		objs = []FactoryDatasetBinarySpecCompression{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetBinarySpecCompression{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetBinarySpecCompressionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetBinarySpecCompression)(ptr) = FactoryDatasetBinarySpecCompression{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetBinarySpecCompression

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetBinarySpecCompression{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetBinarySpecCompression)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetBinarySpecCompression)(ptr) = FactoryDatasetBinarySpecCompression{}
			}
		} else {
			*(*FactoryDatasetBinarySpecCompression)(ptr) = FactoryDatasetBinarySpecCompression{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDatasetBinarySpecCompression

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetBinarySpecCompression{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDatasetBinarySpecCompression)(ptr) = obj
		} else {
			*(*FactoryDatasetBinarySpecCompression)(ptr) = FactoryDatasetBinarySpecCompression{}
		}
	default:
		iter.ReportError("decode FactoryDatasetBinarySpecCompression", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetBinarySpecHttpServerLocationCodec struct {
}

func (FactoryDatasetBinarySpecHttpServerLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetBinarySpecHttpServerLocation)(ptr) == nil
}

func (FactoryDatasetBinarySpecHttpServerLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetBinarySpecHttpServerLocation)(ptr)
	var objs []FactoryDatasetBinarySpecHttpServerLocation
	if obj != nil {
		objs = []FactoryDatasetBinarySpecHttpServerLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetBinarySpecHttpServerLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetBinarySpecHttpServerLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetBinarySpecHttpServerLocation)(ptr) = FactoryDatasetBinarySpecHttpServerLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetBinarySpecHttpServerLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetBinarySpecHttpServerLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetBinarySpecHttpServerLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetBinarySpecHttpServerLocation)(ptr) = FactoryDatasetBinarySpecHttpServerLocation{}
			}
		} else {
			*(*FactoryDatasetBinarySpecHttpServerLocation)(ptr) = FactoryDatasetBinarySpecHttpServerLocation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDatasetBinarySpecHttpServerLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetBinarySpecHttpServerLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDatasetBinarySpecHttpServerLocation)(ptr) = obj
		} else {
			*(*FactoryDatasetBinarySpecHttpServerLocation)(ptr) = FactoryDatasetBinarySpecHttpServerLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetBinarySpecHttpServerLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetBinarySpecSftpServerLocationCodec struct {
}

func (FactoryDatasetBinarySpecSftpServerLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetBinarySpecSftpServerLocation)(ptr) == nil
}

func (FactoryDatasetBinarySpecSftpServerLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetBinarySpecSftpServerLocation)(ptr)
	var objs []FactoryDatasetBinarySpecSftpServerLocation
	if obj != nil {
		objs = []FactoryDatasetBinarySpecSftpServerLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetBinarySpecSftpServerLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetBinarySpecSftpServerLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetBinarySpecSftpServerLocation)(ptr) = FactoryDatasetBinarySpecSftpServerLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetBinarySpecSftpServerLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetBinarySpecSftpServerLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetBinarySpecSftpServerLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetBinarySpecSftpServerLocation)(ptr) = FactoryDatasetBinarySpecSftpServerLocation{}
			}
		} else {
			*(*FactoryDatasetBinarySpecSftpServerLocation)(ptr) = FactoryDatasetBinarySpecSftpServerLocation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDatasetBinarySpecSftpServerLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetBinarySpecSftpServerLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDatasetBinarySpecSftpServerLocation)(ptr) = obj
		} else {
			*(*FactoryDatasetBinarySpecSftpServerLocation)(ptr) = FactoryDatasetBinarySpecSftpServerLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetBinarySpecSftpServerLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetDelimitedTextSpecAzureBlobFsLocationCodec struct {
}

func (FactoryDatasetDelimitedTextSpecAzureBlobFsLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetDelimitedTextSpecAzureBlobFsLocation)(ptr) == nil
}

func (FactoryDatasetDelimitedTextSpecAzureBlobFsLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetDelimitedTextSpecAzureBlobFsLocation)(ptr)
	var objs []FactoryDatasetDelimitedTextSpecAzureBlobFsLocation
	if obj != nil {
		objs = []FactoryDatasetDelimitedTextSpecAzureBlobFsLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobFsLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetDelimitedTextSpecAzureBlobFsLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetDelimitedTextSpecAzureBlobFsLocation)(ptr) = FactoryDatasetDelimitedTextSpecAzureBlobFsLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetDelimitedTextSpecAzureBlobFsLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobFsLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetDelimitedTextSpecAzureBlobFsLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetDelimitedTextSpecAzureBlobFsLocation)(ptr) = FactoryDatasetDelimitedTextSpecAzureBlobFsLocation{}
			}
		} else {
			*(*FactoryDatasetDelimitedTextSpecAzureBlobFsLocation)(ptr) = FactoryDatasetDelimitedTextSpecAzureBlobFsLocation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDatasetDelimitedTextSpecAzureBlobFsLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobFsLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDatasetDelimitedTextSpecAzureBlobFsLocation)(ptr) = obj
		} else {
			*(*FactoryDatasetDelimitedTextSpecAzureBlobFsLocation)(ptr) = FactoryDatasetDelimitedTextSpecAzureBlobFsLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetDelimitedTextSpecAzureBlobFsLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetDelimitedTextSpecAzureBlobStorageLocationCodec struct {
}

func (FactoryDatasetDelimitedTextSpecAzureBlobStorageLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr) == nil
}

func (FactoryDatasetDelimitedTextSpecAzureBlobStorageLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr)
	var objs []FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation
	if obj != nil {
		objs = []FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetDelimitedTextSpecAzureBlobStorageLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}
			}
		} else {
			*(*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr) = obj
		} else {
			*(*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetDelimitedTextSpecHttpServerLocationCodec struct {
}

func (FactoryDatasetDelimitedTextSpecHttpServerLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr) == nil
}

func (FactoryDatasetDelimitedTextSpecHttpServerLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr)
	var objs []FactoryDatasetDelimitedTextSpecHttpServerLocation
	if obj != nil {
		objs = []FactoryDatasetDelimitedTextSpecHttpServerLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecHttpServerLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetDelimitedTextSpecHttpServerLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr) = FactoryDatasetDelimitedTextSpecHttpServerLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetDelimitedTextSpecHttpServerLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecHttpServerLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr) = FactoryDatasetDelimitedTextSpecHttpServerLocation{}
			}
		} else {
			*(*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr) = FactoryDatasetDelimitedTextSpecHttpServerLocation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDatasetDelimitedTextSpecHttpServerLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecHttpServerLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr) = obj
		} else {
			*(*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr) = FactoryDatasetDelimitedTextSpecHttpServerLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetDelimitedTextSpecHttpServerLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetJSONSpecAzureBlobStorageLocationCodec struct {
}

func (FactoryDatasetJSONSpecAzureBlobStorageLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr) == nil
}

func (FactoryDatasetJSONSpecAzureBlobStorageLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr)
	var objs []FactoryDatasetJSONSpecAzureBlobStorageLocation
	if obj != nil {
		objs = []FactoryDatasetJSONSpecAzureBlobStorageLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecAzureBlobStorageLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetJSONSpecAzureBlobStorageLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetJSONSpecAzureBlobStorageLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetJSONSpecAzureBlobStorageLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecAzureBlobStorageLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetJSONSpecAzureBlobStorageLocation{}
			}
		} else {
			*(*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetJSONSpecAzureBlobStorageLocation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDatasetJSONSpecAzureBlobStorageLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecAzureBlobStorageLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr) = obj
		} else {
			*(*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetJSONSpecAzureBlobStorageLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetJSONSpecAzureBlobStorageLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetJSONSpecHttpServerLocationCodec struct {
}

func (FactoryDatasetJSONSpecHttpServerLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetJSONSpecHttpServerLocation)(ptr) == nil
}

func (FactoryDatasetJSONSpecHttpServerLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetJSONSpecHttpServerLocation)(ptr)
	var objs []FactoryDatasetJSONSpecHttpServerLocation
	if obj != nil {
		objs = []FactoryDatasetJSONSpecHttpServerLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecHttpServerLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetJSONSpecHttpServerLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetJSONSpecHttpServerLocation)(ptr) = FactoryDatasetJSONSpecHttpServerLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetJSONSpecHttpServerLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecHttpServerLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetJSONSpecHttpServerLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetJSONSpecHttpServerLocation)(ptr) = FactoryDatasetJSONSpecHttpServerLocation{}
			}
		} else {
			*(*FactoryDatasetJSONSpecHttpServerLocation)(ptr) = FactoryDatasetJSONSpecHttpServerLocation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDatasetJSONSpecHttpServerLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecHttpServerLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDatasetJSONSpecHttpServerLocation)(ptr) = obj
		} else {
			*(*FactoryDatasetJSONSpecHttpServerLocation)(ptr) = FactoryDatasetJSONSpecHttpServerLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetJSONSpecHttpServerLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetParquetSpecAzureBlobStorageLocationCodec struct {
}

func (FactoryDatasetParquetSpecAzureBlobStorageLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr) == nil
}

func (FactoryDatasetParquetSpecAzureBlobStorageLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr)
	var objs []FactoryDatasetParquetSpecAzureBlobStorageLocation
	if obj != nil {
		objs = []FactoryDatasetParquetSpecAzureBlobStorageLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecAzureBlobStorageLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetParquetSpecAzureBlobStorageLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetParquetSpecAzureBlobStorageLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetParquetSpecAzureBlobStorageLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecAzureBlobStorageLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetParquetSpecAzureBlobStorageLocation{}
			}
		} else {
			*(*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetParquetSpecAzureBlobStorageLocation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDatasetParquetSpecAzureBlobStorageLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecAzureBlobStorageLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr) = obj
		} else {
			*(*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetParquetSpecAzureBlobStorageLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetParquetSpecAzureBlobStorageLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetParquetSpecHttpServerLocationCodec struct {
}

func (FactoryDatasetParquetSpecHttpServerLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetParquetSpecHttpServerLocation)(ptr) == nil
}

func (FactoryDatasetParquetSpecHttpServerLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetParquetSpecHttpServerLocation)(ptr)
	var objs []FactoryDatasetParquetSpecHttpServerLocation
	if obj != nil {
		objs = []FactoryDatasetParquetSpecHttpServerLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecHttpServerLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetParquetSpecHttpServerLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetParquetSpecHttpServerLocation)(ptr) = FactoryDatasetParquetSpecHttpServerLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetParquetSpecHttpServerLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecHttpServerLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetParquetSpecHttpServerLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetParquetSpecHttpServerLocation)(ptr) = FactoryDatasetParquetSpecHttpServerLocation{}
			}
		} else {
			*(*FactoryDatasetParquetSpecHttpServerLocation)(ptr) = FactoryDatasetParquetSpecHttpServerLocation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryDatasetParquetSpecHttpServerLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecHttpServerLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryDatasetParquetSpecHttpServerLocation)(ptr) = obj
		} else {
			*(*FactoryDatasetParquetSpecHttpServerLocation)(ptr) = FactoryDatasetParquetSpecHttpServerLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetParquetSpecHttpServerLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeAzureSsisSpecCatalogInfoCodec struct {
}

func (FactoryIntegrationRuntimeAzureSsisSpecCatalogInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr) == nil
}

func (FactoryIntegrationRuntimeAzureSsisSpecCatalogInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr)
	var objs []FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo
	if obj != nil {
		objs = []FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeAzureSsisSpecCatalogInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}
			}
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr) = obj
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScriptCodec struct {
}

func (FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScriptCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr) == nil
}

func (FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScriptCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr)
	var objs []FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript
	if obj != nil {
		objs = []FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScriptCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}
			}
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr) = obj
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCodec struct {
}

func (FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup)(ptr) == nil
}

func (FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup)(ptr)
	var objs []FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup
	if obj != nil {
		objs = []FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup{}
			}
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup)(ptr) = obj
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetup", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPasswordCodec struct {
}

func (FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPasswordCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword)(ptr) == nil
}

func (FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPasswordCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword)(ptr)
	var objs []FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword
	if obj != nil {
		objs = []FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPasswordCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword{}
			}
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword)(ptr) = obj
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupCommandKeyKeyVaultPassword", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicenseCodec struct {
}

func (FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicenseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense)(ptr) == nil
}

func (FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicenseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense)(ptr)
	var objs []FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense
	if obj != nil {
		objs = []FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicenseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense{}
			}
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense)(ptr) = obj
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeAzureSsisSpecExpressCustomSetupComponentKeyVaultLicense", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeAzureSsisSpecProxyCodec struct {
}

func (FactoryIntegrationRuntimeAzureSsisSpecProxyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeAzureSsisSpecProxy)(ptr) == nil
}

func (FactoryIntegrationRuntimeAzureSsisSpecProxyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeAzureSsisSpecProxy)(ptr)
	var objs []FactoryIntegrationRuntimeAzureSsisSpecProxy
	if obj != nil {
		objs = []FactoryIntegrationRuntimeAzureSsisSpecProxy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecProxy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeAzureSsisSpecProxyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeAzureSsisSpecProxy)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecProxy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeAzureSsisSpecProxy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecProxy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeAzureSsisSpecProxy)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeAzureSsisSpecProxy)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecProxy{}
			}
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecProxy)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecProxy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryIntegrationRuntimeAzureSsisSpecProxy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecProxy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryIntegrationRuntimeAzureSsisSpecProxy)(ptr) = obj
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecProxy)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecProxy{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeAzureSsisSpecProxy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeAzureSsisSpecVnetIntegrationCodec struct {
}

func (FactoryIntegrationRuntimeAzureSsisSpecVnetIntegrationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr) == nil
}

func (FactoryIntegrationRuntimeAzureSsisSpecVnetIntegrationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr)
	var objs []FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration
	if obj != nil {
		objs = []FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeAzureSsisSpecVnetIntegrationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}
			}
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr) = obj
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeManagedSpecCatalogInfoCodec struct {
}

func (FactoryIntegrationRuntimeManagedSpecCatalogInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr) == nil
}

func (FactoryIntegrationRuntimeManagedSpecCatalogInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr)
	var objs []FactoryIntegrationRuntimeManagedSpecCatalogInfo
	if obj != nil {
		objs = []FactoryIntegrationRuntimeManagedSpecCatalogInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCatalogInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeManagedSpecCatalogInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeManagedSpecCatalogInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeManagedSpecCatalogInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCatalogInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeManagedSpecCatalogInfo{}
			}
		} else {
			*(*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeManagedSpecCatalogInfo{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryIntegrationRuntimeManagedSpecCatalogInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCatalogInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr) = obj
		} else {
			*(*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeManagedSpecCatalogInfo{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeManagedSpecCatalogInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeManagedSpecCustomSetupScriptCodec struct {
}

func (FactoryIntegrationRuntimeManagedSpecCustomSetupScriptCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr) == nil
}

func (FactoryIntegrationRuntimeManagedSpecCustomSetupScriptCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr)
	var objs []FactoryIntegrationRuntimeManagedSpecCustomSetupScript
	if obj != nil {
		objs = []FactoryIntegrationRuntimeManagedSpecCustomSetupScript{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeManagedSpecCustomSetupScriptCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeManagedSpecCustomSetupScript

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}
			}
		} else {
			*(*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryIntegrationRuntimeManagedSpecCustomSetupScript

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr) = obj
		} else {
			*(*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeManagedSpecCustomSetupScript", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeManagedSpecVnetIntegrationCodec struct {
}

func (FactoryIntegrationRuntimeManagedSpecVnetIntegrationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr) == nil
}

func (FactoryIntegrationRuntimeManagedSpecVnetIntegrationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr)
	var objs []FactoryIntegrationRuntimeManagedSpecVnetIntegration
	if obj != nil {
		objs = []FactoryIntegrationRuntimeManagedSpecVnetIntegration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecVnetIntegration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeManagedSpecVnetIntegrationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeManagedSpecVnetIntegration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeManagedSpecVnetIntegration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecVnetIntegration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeManagedSpecVnetIntegration{}
			}
		} else {
			*(*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeManagedSpecVnetIntegration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryIntegrationRuntimeManagedSpecVnetIntegration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecVnetIntegration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr) = obj
		} else {
			*(*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeManagedSpecVnetIntegration{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeManagedSpecVnetIntegration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedCustomServiceSpecIntegrationRuntimeCodec struct {
}

func (FactoryLinkedCustomServiceSpecIntegrationRuntimeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedCustomServiceSpecIntegrationRuntime)(ptr) == nil
}

func (FactoryLinkedCustomServiceSpecIntegrationRuntimeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedCustomServiceSpecIntegrationRuntime)(ptr)
	var objs []FactoryLinkedCustomServiceSpecIntegrationRuntime
	if obj != nil {
		objs = []FactoryLinkedCustomServiceSpecIntegrationRuntime{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedCustomServiceSpecIntegrationRuntime{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedCustomServiceSpecIntegrationRuntimeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedCustomServiceSpecIntegrationRuntime)(ptr) = FactoryLinkedCustomServiceSpecIntegrationRuntime{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedCustomServiceSpecIntegrationRuntime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedCustomServiceSpecIntegrationRuntime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedCustomServiceSpecIntegrationRuntime)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedCustomServiceSpecIntegrationRuntime)(ptr) = FactoryLinkedCustomServiceSpecIntegrationRuntime{}
			}
		} else {
			*(*FactoryLinkedCustomServiceSpecIntegrationRuntime)(ptr) = FactoryLinkedCustomServiceSpecIntegrationRuntime{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedCustomServiceSpecIntegrationRuntime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedCustomServiceSpecIntegrationRuntime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedCustomServiceSpecIntegrationRuntime)(ptr) = obj
		} else {
			*(*FactoryLinkedCustomServiceSpecIntegrationRuntime)(ptr) = FactoryLinkedCustomServiceSpecIntegrationRuntime{}
		}
	default:
		iter.ReportError("decode FactoryLinkedCustomServiceSpecIntegrationRuntime", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasTokenCodec struct {
}

func (FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasTokenCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken)(ptr) == nil
}

func (FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasTokenCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken)(ptr)
	var objs []FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken
	if obj != nil {
		objs = []FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasTokenCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken)(ptr) = FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken)(ptr) = FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken{}
			}
		} else {
			*(*FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken)(ptr) = FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken)(ptr) = FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceAzureBlobStorageSpecKeyVaultSasToken", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceAzureDatabricksSpecInstancePoolCodec struct {
}

func (FactoryLinkedServiceAzureDatabricksSpecInstancePoolCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr) == nil
}

func (FactoryLinkedServiceAzureDatabricksSpecInstancePoolCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr)
	var objs []FactoryLinkedServiceAzureDatabricksSpecInstancePool
	if obj != nil {
		objs = []FactoryLinkedServiceAzureDatabricksSpecInstancePool{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecInstancePool{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceAzureDatabricksSpecInstancePoolCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr) = FactoryLinkedServiceAzureDatabricksSpecInstancePool{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceAzureDatabricksSpecInstancePool

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecInstancePool{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr) = FactoryLinkedServiceAzureDatabricksSpecInstancePool{}
			}
		} else {
			*(*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr) = FactoryLinkedServiceAzureDatabricksSpecInstancePool{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceAzureDatabricksSpecInstancePool

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecInstancePool{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr) = FactoryLinkedServiceAzureDatabricksSpecInstancePool{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceAzureDatabricksSpecInstancePool", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceAzureDatabricksSpecKeyVaultPasswordCodec struct {
}

func (FactoryLinkedServiceAzureDatabricksSpecKeyVaultPasswordCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr) == nil
}

func (FactoryLinkedServiceAzureDatabricksSpecKeyVaultPasswordCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr)
	var objs []FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword
	if obj != nil {
		objs = []FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceAzureDatabricksSpecKeyVaultPasswordCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}
			}
		} else {
			*(*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceAzureDatabricksSpecNewClusterConfigCodec struct {
}

func (FactoryLinkedServiceAzureDatabricksSpecNewClusterConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr) == nil
}

func (FactoryLinkedServiceAzureDatabricksSpecNewClusterConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr)
	var objs []FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig
	if obj != nil {
		objs = []FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceAzureDatabricksSpecNewClusterConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr) = FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr) = FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}
			}
		} else {
			*(*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr) = FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr) = FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceAzureFileStorageSpecKeyVaultPasswordCodec struct {
}

func (FactoryLinkedServiceAzureFileStorageSpecKeyVaultPasswordCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr) == nil
}

func (FactoryLinkedServiceAzureFileStorageSpecKeyVaultPasswordCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr)
	var objs []FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword
	if obj != nil {
		objs = []FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceAzureFileStorageSpecKeyVaultPasswordCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}
			}
		} else {
			*(*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceAzureFunctionSpecKeyVaultKeyCodec struct {
}

func (FactoryLinkedServiceAzureFunctionSpecKeyVaultKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceAzureFunctionSpecKeyVaultKey)(ptr) == nil
}

func (FactoryLinkedServiceAzureFunctionSpecKeyVaultKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceAzureFunctionSpecKeyVaultKey)(ptr)
	var objs []FactoryLinkedServiceAzureFunctionSpecKeyVaultKey
	if obj != nil {
		objs = []FactoryLinkedServiceAzureFunctionSpecKeyVaultKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureFunctionSpecKeyVaultKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceAzureFunctionSpecKeyVaultKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceAzureFunctionSpecKeyVaultKey)(ptr) = FactoryLinkedServiceAzureFunctionSpecKeyVaultKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceAzureFunctionSpecKeyVaultKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureFunctionSpecKeyVaultKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceAzureFunctionSpecKeyVaultKey)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceAzureFunctionSpecKeyVaultKey)(ptr) = FactoryLinkedServiceAzureFunctionSpecKeyVaultKey{}
			}
		} else {
			*(*FactoryLinkedServiceAzureFunctionSpecKeyVaultKey)(ptr) = FactoryLinkedServiceAzureFunctionSpecKeyVaultKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceAzureFunctionSpecKeyVaultKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureFunctionSpecKeyVaultKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceAzureFunctionSpecKeyVaultKey)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceAzureFunctionSpecKeyVaultKey)(ptr) = FactoryLinkedServiceAzureFunctionSpecKeyVaultKey{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceAzureFunctionSpecKeyVaultKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionStringCodec struct {
}

func (FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionStringCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString)(ptr) == nil
}

func (FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionStringCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString)(ptr)
	var objs []FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString
	if obj != nil {
		objs = []FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionStringCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString)(ptr) = FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString)(ptr) = FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString{}
			}
		} else {
			*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString)(ptr) = FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString)(ptr) = FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultConnectionString", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPasswordCodec struct {
}

func (FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPasswordCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr) == nil
}

func (FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPasswordCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr)
	var objs []FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword
	if obj != nil {
		objs = []FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPasswordCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}
			}
		} else {
			*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceOdataSpecBasicAuthenticationCodec struct {
}

func (FactoryLinkedServiceOdataSpecBasicAuthenticationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceOdataSpecBasicAuthentication)(ptr) == nil
}

func (FactoryLinkedServiceOdataSpecBasicAuthenticationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceOdataSpecBasicAuthentication)(ptr)
	var objs []FactoryLinkedServiceOdataSpecBasicAuthentication
	if obj != nil {
		objs = []FactoryLinkedServiceOdataSpecBasicAuthentication{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceOdataSpecBasicAuthentication{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceOdataSpecBasicAuthenticationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceOdataSpecBasicAuthentication)(ptr) = FactoryLinkedServiceOdataSpecBasicAuthentication{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceOdataSpecBasicAuthentication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceOdataSpecBasicAuthentication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceOdataSpecBasicAuthentication)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceOdataSpecBasicAuthentication)(ptr) = FactoryLinkedServiceOdataSpecBasicAuthentication{}
			}
		} else {
			*(*FactoryLinkedServiceOdataSpecBasicAuthentication)(ptr) = FactoryLinkedServiceOdataSpecBasicAuthentication{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceOdataSpecBasicAuthentication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceOdataSpecBasicAuthentication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceOdataSpecBasicAuthentication)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceOdataSpecBasicAuthentication)(ptr) = FactoryLinkedServiceOdataSpecBasicAuthentication{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceOdataSpecBasicAuthentication", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceOdbcSpecBasicAuthenticationCodec struct {
}

func (FactoryLinkedServiceOdbcSpecBasicAuthenticationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceOdbcSpecBasicAuthentication)(ptr) == nil
}

func (FactoryLinkedServiceOdbcSpecBasicAuthenticationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceOdbcSpecBasicAuthentication)(ptr)
	var objs []FactoryLinkedServiceOdbcSpecBasicAuthentication
	if obj != nil {
		objs = []FactoryLinkedServiceOdbcSpecBasicAuthentication{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceOdbcSpecBasicAuthentication{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceOdbcSpecBasicAuthenticationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceOdbcSpecBasicAuthentication)(ptr) = FactoryLinkedServiceOdbcSpecBasicAuthentication{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceOdbcSpecBasicAuthentication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceOdbcSpecBasicAuthentication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceOdbcSpecBasicAuthentication)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceOdbcSpecBasicAuthentication)(ptr) = FactoryLinkedServiceOdbcSpecBasicAuthentication{}
			}
		} else {
			*(*FactoryLinkedServiceOdbcSpecBasicAuthentication)(ptr) = FactoryLinkedServiceOdbcSpecBasicAuthentication{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceOdbcSpecBasicAuthentication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceOdbcSpecBasicAuthentication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceOdbcSpecBasicAuthentication)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceOdbcSpecBasicAuthentication)(ptr) = FactoryLinkedServiceOdbcSpecBasicAuthentication{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceOdbcSpecBasicAuthentication", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceSnowflakeSpecKeyVaultPasswordCodec struct {
}

func (FactoryLinkedServiceSnowflakeSpecKeyVaultPasswordCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr) == nil
}

func (FactoryLinkedServiceSnowflakeSpecKeyVaultPasswordCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr)
	var objs []FactoryLinkedServiceSnowflakeSpecKeyVaultPassword
	if obj != nil {
		objs = []FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceSnowflakeSpecKeyVaultPasswordCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceSnowflakeSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}
			}
		} else {
			*(*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceSnowflakeSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceSnowflakeSpecKeyVaultPassword", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceSQLServerSpecKeyVaultConnectionStringCodec struct {
}

func (FactoryLinkedServiceSQLServerSpecKeyVaultConnectionStringCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString)(ptr) == nil
}

func (FactoryLinkedServiceSQLServerSpecKeyVaultConnectionStringCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString)(ptr)
	var objs []FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString
	if obj != nil {
		objs = []FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceSQLServerSpecKeyVaultConnectionStringCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString)(ptr) = FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString)(ptr) = FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString{}
			}
		} else {
			*(*FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString)(ptr) = FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString)(ptr) = FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceSQLServerSpecKeyVaultConnectionString", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceSQLServerSpecKeyVaultPasswordCodec struct {
}

func (FactoryLinkedServiceSQLServerSpecKeyVaultPasswordCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr) == nil
}

func (FactoryLinkedServiceSQLServerSpecKeyVaultPasswordCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr)
	var objs []FactoryLinkedServiceSQLServerSpecKeyVaultPassword
	if obj != nil {
		objs = []FactoryLinkedServiceSQLServerSpecKeyVaultPassword{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceSQLServerSpecKeyVaultPasswordCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceSQLServerSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}
			}
		} else {
			*(*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceSQLServerSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceSQLServerSpecKeyVaultPassword", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceSynapseSpecKeyVaultPasswordCodec struct {
}

func (FactoryLinkedServiceSynapseSpecKeyVaultPasswordCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr) == nil
}

func (FactoryLinkedServiceSynapseSpecKeyVaultPasswordCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr)
	var objs []FactoryLinkedServiceSynapseSpecKeyVaultPassword
	if obj != nil {
		objs = []FactoryLinkedServiceSynapseSpecKeyVaultPassword{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSynapseSpecKeyVaultPassword{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceSynapseSpecKeyVaultPasswordCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSynapseSpecKeyVaultPassword{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceSynapseSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSynapseSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSynapseSpecKeyVaultPassword{}
			}
		} else {
			*(*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSynapseSpecKeyVaultPassword{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryLinkedServiceSynapseSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSynapseSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr) = obj
		} else {
			*(*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSynapseSpecKeyVaultPassword{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceSynapseSpecKeyVaultPassword", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryTriggerScheduleSpecScheduleCodec struct {
}

func (FactoryTriggerScheduleSpecScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryTriggerScheduleSpecSchedule)(ptr) == nil
}

func (FactoryTriggerScheduleSpecScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryTriggerScheduleSpecSchedule)(ptr)
	var objs []FactoryTriggerScheduleSpecSchedule
	if obj != nil {
		objs = []FactoryTriggerScheduleSpecSchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryTriggerScheduleSpecSchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryTriggerScheduleSpecScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryTriggerScheduleSpecSchedule)(ptr) = FactoryTriggerScheduleSpecSchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryTriggerScheduleSpecSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryTriggerScheduleSpecSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryTriggerScheduleSpecSchedule)(ptr) = objs[0]
			} else {
				*(*FactoryTriggerScheduleSpecSchedule)(ptr) = FactoryTriggerScheduleSpecSchedule{}
			}
		} else {
			*(*FactoryTriggerScheduleSpecSchedule)(ptr) = FactoryTriggerScheduleSpecSchedule{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryTriggerScheduleSpecSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryTriggerScheduleSpecSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryTriggerScheduleSpecSchedule)(ptr) = obj
		} else {
			*(*FactoryTriggerScheduleSpecSchedule)(ptr) = FactoryTriggerScheduleSpecSchedule{}
		}
	default:
		iter.ReportError("decode FactoryTriggerScheduleSpecSchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryTriggerTumblingWindowSpecPipelineCodec struct {
}

func (FactoryTriggerTumblingWindowSpecPipelineCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryTriggerTumblingWindowSpecPipeline)(ptr) == nil
}

func (FactoryTriggerTumblingWindowSpecPipelineCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryTriggerTumblingWindowSpecPipeline)(ptr)
	var objs []FactoryTriggerTumblingWindowSpecPipeline
	if obj != nil {
		objs = []FactoryTriggerTumblingWindowSpecPipeline{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryTriggerTumblingWindowSpecPipeline{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryTriggerTumblingWindowSpecPipelineCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryTriggerTumblingWindowSpecPipeline)(ptr) = FactoryTriggerTumblingWindowSpecPipeline{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryTriggerTumblingWindowSpecPipeline

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryTriggerTumblingWindowSpecPipeline{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryTriggerTumblingWindowSpecPipeline)(ptr) = objs[0]
			} else {
				*(*FactoryTriggerTumblingWindowSpecPipeline)(ptr) = FactoryTriggerTumblingWindowSpecPipeline{}
			}
		} else {
			*(*FactoryTriggerTumblingWindowSpecPipeline)(ptr) = FactoryTriggerTumblingWindowSpecPipeline{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryTriggerTumblingWindowSpecPipeline

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryTriggerTumblingWindowSpecPipeline{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryTriggerTumblingWindowSpecPipeline)(ptr) = obj
		} else {
			*(*FactoryTriggerTumblingWindowSpecPipeline)(ptr) = FactoryTriggerTumblingWindowSpecPipeline{}
		}
	default:
		iter.ReportError("decode FactoryTriggerTumblingWindowSpecPipeline", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryTriggerTumblingWindowSpecRetryCodec struct {
}

func (FactoryTriggerTumblingWindowSpecRetryCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryTriggerTumblingWindowSpecRetry)(ptr) == nil
}

func (FactoryTriggerTumblingWindowSpecRetryCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryTriggerTumblingWindowSpecRetry)(ptr)
	var objs []FactoryTriggerTumblingWindowSpecRetry
	if obj != nil {
		objs = []FactoryTriggerTumblingWindowSpecRetry{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryTriggerTumblingWindowSpecRetry{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryTriggerTumblingWindowSpecRetryCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryTriggerTumblingWindowSpecRetry)(ptr) = FactoryTriggerTumblingWindowSpecRetry{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryTriggerTumblingWindowSpecRetry

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryTriggerTumblingWindowSpecRetry{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryTriggerTumblingWindowSpecRetry)(ptr) = objs[0]
			} else {
				*(*FactoryTriggerTumblingWindowSpecRetry)(ptr) = FactoryTriggerTumblingWindowSpecRetry{}
			}
		} else {
			*(*FactoryTriggerTumblingWindowSpecRetry)(ptr) = FactoryTriggerTumblingWindowSpecRetry{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FactoryTriggerTumblingWindowSpecRetry

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryTriggerTumblingWindowSpecRetry{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FactoryTriggerTumblingWindowSpecRetry)(ptr) = obj
		} else {
			*(*FactoryTriggerTumblingWindowSpecRetry)(ptr) = FactoryTriggerTumblingWindowSpecRetry{}
		}
	default:
		iter.ReportError("decode FactoryTriggerTumblingWindowSpecRetry", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LakeStoreSpecIdentityCodec struct {
}

func (LakeStoreSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LakeStoreSpecIdentity)(ptr) == nil
}

func (LakeStoreSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LakeStoreSpecIdentity)(ptr)
	var objs []LakeStoreSpecIdentity
	if obj != nil {
		objs = []LakeStoreSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LakeStoreSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LakeStoreSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LakeStoreSpecIdentity)(ptr) = LakeStoreSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LakeStoreSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LakeStoreSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LakeStoreSpecIdentity)(ptr) = objs[0]
			} else {
				*(*LakeStoreSpecIdentity)(ptr) = LakeStoreSpecIdentity{}
			}
		} else {
			*(*LakeStoreSpecIdentity)(ptr) = LakeStoreSpecIdentity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj LakeStoreSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LakeStoreSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*LakeStoreSpecIdentity)(ptr) = obj
		} else {
			*(*LakeStoreSpecIdentity)(ptr) = LakeStoreSpecIdentity{}
		}
	default:
		iter.ReportError("decode LakeStoreSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ProtectionBackupPolicyDiskSpecRetentionRuleCriteriaCodec struct {
}

func (ProtectionBackupPolicyDiskSpecRetentionRuleCriteriaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ProtectionBackupPolicyDiskSpecRetentionRuleCriteria)(ptr) == nil
}

func (ProtectionBackupPolicyDiskSpecRetentionRuleCriteriaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ProtectionBackupPolicyDiskSpecRetentionRuleCriteria)(ptr)
	var objs []ProtectionBackupPolicyDiskSpecRetentionRuleCriteria
	if obj != nil {
		objs = []ProtectionBackupPolicyDiskSpecRetentionRuleCriteria{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupPolicyDiskSpecRetentionRuleCriteria{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ProtectionBackupPolicyDiskSpecRetentionRuleCriteriaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ProtectionBackupPolicyDiskSpecRetentionRuleCriteria)(ptr) = ProtectionBackupPolicyDiskSpecRetentionRuleCriteria{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ProtectionBackupPolicyDiskSpecRetentionRuleCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupPolicyDiskSpecRetentionRuleCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ProtectionBackupPolicyDiskSpecRetentionRuleCriteria)(ptr) = objs[0]
			} else {
				*(*ProtectionBackupPolicyDiskSpecRetentionRuleCriteria)(ptr) = ProtectionBackupPolicyDiskSpecRetentionRuleCriteria{}
			}
		} else {
			*(*ProtectionBackupPolicyDiskSpecRetentionRuleCriteria)(ptr) = ProtectionBackupPolicyDiskSpecRetentionRuleCriteria{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ProtectionBackupPolicyDiskSpecRetentionRuleCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupPolicyDiskSpecRetentionRuleCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ProtectionBackupPolicyDiskSpecRetentionRuleCriteria)(ptr) = obj
		} else {
			*(*ProtectionBackupPolicyDiskSpecRetentionRuleCriteria)(ptr) = ProtectionBackupPolicyDiskSpecRetentionRuleCriteria{}
		}
	default:
		iter.ReportError("decode ProtectionBackupPolicyDiskSpecRetentionRuleCriteria", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteriaCodec struct {
}

func (ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteriaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria)(ptr) == nil
}

func (ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteriaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria)(ptr)
	var objs []ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria
	if obj != nil {
		objs = []ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteriaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria)(ptr) = ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria)(ptr) = objs[0]
			} else {
				*(*ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria)(ptr) = ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria{}
			}
		} else {
			*(*ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria)(ptr) = ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria)(ptr) = obj
		} else {
			*(*ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria)(ptr) = ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria{}
		}
	default:
		iter.ReportError("decode ProtectionBackupPolicyPostgresqlSpecRetentionRuleCriteria", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ProtectionBackupVaultSpecIdentityCodec struct {
}

func (ProtectionBackupVaultSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ProtectionBackupVaultSpecIdentity)(ptr) == nil
}

func (ProtectionBackupVaultSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ProtectionBackupVaultSpecIdentity)(ptr)
	var objs []ProtectionBackupVaultSpecIdentity
	if obj != nil {
		objs = []ProtectionBackupVaultSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupVaultSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ProtectionBackupVaultSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ProtectionBackupVaultSpecIdentity)(ptr) = ProtectionBackupVaultSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ProtectionBackupVaultSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupVaultSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ProtectionBackupVaultSpecIdentity)(ptr) = objs[0]
			} else {
				*(*ProtectionBackupVaultSpecIdentity)(ptr) = ProtectionBackupVaultSpecIdentity{}
			}
		} else {
			*(*ProtectionBackupVaultSpecIdentity)(ptr) = ProtectionBackupVaultSpecIdentity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ProtectionBackupVaultSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ProtectionBackupVaultSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ProtectionBackupVaultSpecIdentity)(ptr) = obj
		} else {
			*(*ProtectionBackupVaultSpecIdentity)(ptr) = ProtectionBackupVaultSpecIdentity{}
		}
	default:
		iter.ReportError("decode ProtectionBackupVaultSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ShareSpecSnapshotScheduleCodec struct {
}

func (ShareSpecSnapshotScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ShareSpecSnapshotSchedule)(ptr) == nil
}

func (ShareSpecSnapshotScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ShareSpecSnapshotSchedule)(ptr)
	var objs []ShareSpecSnapshotSchedule
	if obj != nil {
		objs = []ShareSpecSnapshotSchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareSpecSnapshotSchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ShareSpecSnapshotScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ShareSpecSnapshotSchedule)(ptr) = ShareSpecSnapshotSchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ShareSpecSnapshotSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareSpecSnapshotSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ShareSpecSnapshotSchedule)(ptr) = objs[0]
			} else {
				*(*ShareSpecSnapshotSchedule)(ptr) = ShareSpecSnapshotSchedule{}
			}
		} else {
			*(*ShareSpecSnapshotSchedule)(ptr) = ShareSpecSnapshotSchedule{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ShareSpecSnapshotSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareSpecSnapshotSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ShareSpecSnapshotSchedule)(ptr) = obj
		} else {
			*(*ShareSpecSnapshotSchedule)(ptr) = ShareSpecSnapshotSchedule{}
		}
	default:
		iter.ReportError("decode ShareSpecSnapshotSchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ShareAccountSpecIdentityCodec struct {
}

func (ShareAccountSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ShareAccountSpecIdentity)(ptr) == nil
}

func (ShareAccountSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ShareAccountSpecIdentity)(ptr)
	var objs []ShareAccountSpecIdentity
	if obj != nil {
		objs = []ShareAccountSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareAccountSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ShareAccountSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ShareAccountSpecIdentity)(ptr) = ShareAccountSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ShareAccountSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareAccountSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ShareAccountSpecIdentity)(ptr) = objs[0]
			} else {
				*(*ShareAccountSpecIdentity)(ptr) = ShareAccountSpecIdentity{}
			}
		} else {
			*(*ShareAccountSpecIdentity)(ptr) = ShareAccountSpecIdentity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ShareAccountSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareAccountSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ShareAccountSpecIdentity)(ptr) = obj
		} else {
			*(*ShareAccountSpecIdentity)(ptr) = ShareAccountSpecIdentity{}
		}
	default:
		iter.ReportError("decode ShareAccountSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ShareDatasetBlobStorageSpecStorageAccountCodec struct {
}

func (ShareDatasetBlobStorageSpecStorageAccountCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ShareDatasetBlobStorageSpecStorageAccount)(ptr) == nil
}

func (ShareDatasetBlobStorageSpecStorageAccountCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ShareDatasetBlobStorageSpecStorageAccount)(ptr)
	var objs []ShareDatasetBlobStorageSpecStorageAccount
	if obj != nil {
		objs = []ShareDatasetBlobStorageSpecStorageAccount{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareDatasetBlobStorageSpecStorageAccount{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ShareDatasetBlobStorageSpecStorageAccountCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ShareDatasetBlobStorageSpecStorageAccount)(ptr) = ShareDatasetBlobStorageSpecStorageAccount{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ShareDatasetBlobStorageSpecStorageAccount

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareDatasetBlobStorageSpecStorageAccount{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ShareDatasetBlobStorageSpecStorageAccount)(ptr) = objs[0]
			} else {
				*(*ShareDatasetBlobStorageSpecStorageAccount)(ptr) = ShareDatasetBlobStorageSpecStorageAccount{}
			}
		} else {
			*(*ShareDatasetBlobStorageSpecStorageAccount)(ptr) = ShareDatasetBlobStorageSpecStorageAccount{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ShareDatasetBlobStorageSpecStorageAccount

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareDatasetBlobStorageSpecStorageAccount{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ShareDatasetBlobStorageSpecStorageAccount)(ptr) = obj
		} else {
			*(*ShareDatasetBlobStorageSpecStorageAccount)(ptr) = ShareDatasetBlobStorageSpecStorageAccount{}
		}
	default:
		iter.ReportError("decode ShareDatasetBlobStorageSpecStorageAccount", "unexpected JSON type")
	}
}

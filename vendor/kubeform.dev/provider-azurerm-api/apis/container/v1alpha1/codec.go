/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerGpu{}).Type1()):                       GroupSpecContainerGpuCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerLivenessProbe{}).Type1()):             GroupSpecContainerLivenessProbeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerReadinessProbe{}).Type1()):            GroupSpecContainerReadinessProbeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerVolumeGitRepo{}).Type1()):             GroupSpecContainerVolumeGitRepoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDiagnostics{}).Type1()):                        GroupSpecDiagnosticsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDiagnosticsLogAnalytics{}).Type1()):            GroupSpecDiagnosticsLogAnalyticsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDnsConfig{}).Type1()):                          GroupSpecDnsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecIdentity{}).Type1()):                           GroupSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecEncryption{}).Type1()):                      RegistrySpecEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecIdentity{}).Type1()):                        RegistrySpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecNetworkRuleSet{}).Type1()):                  RegistrySpecNetworkRuleSetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecRetentionPolicy{}).Type1()):                 RegistrySpecRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecTrustPolicy{}).Type1()):                     RegistrySpecTrustPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecAgentSetting{}).Type1()):                RegistryTaskSpecAgentSettingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecBaseImageTrigger{}).Type1()):            RegistryTaskSpecBaseImageTriggerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecDockerStep{}).Type1()):                  RegistryTaskSpecDockerStepCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecEncodedStep{}).Type1()):                 RegistryTaskSpecEncodedStepCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecFileStep{}).Type1()):                    RegistryTaskSpecFileStepCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecIdentity{}).Type1()):                    RegistryTaskSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecPlatform{}).Type1()):                    RegistryTaskSpecPlatformCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecRegistryCredential{}).Type1()):          RegistryTaskSpecRegistryCredentialCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecRegistryCredentialSource{}).Type1()):    RegistryTaskSpecRegistryCredentialSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecSourceTriggerAuthentication{}).Type1()): RegistryTaskSpecSourceTriggerAuthenticationCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerGpu{}).Type1()):                       GroupSpecContainerGpuCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerLivenessProbe{}).Type1()):             GroupSpecContainerLivenessProbeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerReadinessProbe{}).Type1()):            GroupSpecContainerReadinessProbeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerVolumeGitRepo{}).Type1()):             GroupSpecContainerVolumeGitRepoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDiagnostics{}).Type1()):                        GroupSpecDiagnosticsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDiagnosticsLogAnalytics{}).Type1()):            GroupSpecDiagnosticsLogAnalyticsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDnsConfig{}).Type1()):                          GroupSpecDnsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecIdentity{}).Type1()):                           GroupSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecEncryption{}).Type1()):                      RegistrySpecEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecIdentity{}).Type1()):                        RegistrySpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecNetworkRuleSet{}).Type1()):                  RegistrySpecNetworkRuleSetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecRetentionPolicy{}).Type1()):                 RegistrySpecRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecTrustPolicy{}).Type1()):                     RegistrySpecTrustPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecAgentSetting{}).Type1()):                RegistryTaskSpecAgentSettingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecBaseImageTrigger{}).Type1()):            RegistryTaskSpecBaseImageTriggerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecDockerStep{}).Type1()):                  RegistryTaskSpecDockerStepCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecEncodedStep{}).Type1()):                 RegistryTaskSpecEncodedStepCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecFileStep{}).Type1()):                    RegistryTaskSpecFileStepCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecIdentity{}).Type1()):                    RegistryTaskSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecPlatform{}).Type1()):                    RegistryTaskSpecPlatformCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecRegistryCredential{}).Type1()):          RegistryTaskSpecRegistryCredentialCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecRegistryCredentialSource{}).Type1()):    RegistryTaskSpecRegistryCredentialSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecSourceTriggerAuthentication{}).Type1()): RegistryTaskSpecSourceTriggerAuthenticationCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type GroupSpecContainerGpuCodec struct {
}

func (GroupSpecContainerGpuCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecContainerGpu)(ptr) == nil
}

func (GroupSpecContainerGpuCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecContainerGpu)(ptr)
	var objs []GroupSpecContainerGpu
	if obj != nil {
		objs = []GroupSpecContainerGpu{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerGpu{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecContainerGpuCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecContainerGpu)(ptr) = GroupSpecContainerGpu{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecContainerGpu

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerGpu{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecContainerGpu)(ptr) = objs[0]
			} else {
				*(*GroupSpecContainerGpu)(ptr) = GroupSpecContainerGpu{}
			}
		} else {
			*(*GroupSpecContainerGpu)(ptr) = GroupSpecContainerGpu{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj GroupSpecContainerGpu

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerGpu{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*GroupSpecContainerGpu)(ptr) = obj
		} else {
			*(*GroupSpecContainerGpu)(ptr) = GroupSpecContainerGpu{}
		}
	default:
		iter.ReportError("decode GroupSpecContainerGpu", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecContainerLivenessProbeCodec struct {
}

func (GroupSpecContainerLivenessProbeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecContainerLivenessProbe)(ptr) == nil
}

func (GroupSpecContainerLivenessProbeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecContainerLivenessProbe)(ptr)
	var objs []GroupSpecContainerLivenessProbe
	if obj != nil {
		objs = []GroupSpecContainerLivenessProbe{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerLivenessProbe{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecContainerLivenessProbeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecContainerLivenessProbe)(ptr) = GroupSpecContainerLivenessProbe{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecContainerLivenessProbe

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerLivenessProbe{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecContainerLivenessProbe)(ptr) = objs[0]
			} else {
				*(*GroupSpecContainerLivenessProbe)(ptr) = GroupSpecContainerLivenessProbe{}
			}
		} else {
			*(*GroupSpecContainerLivenessProbe)(ptr) = GroupSpecContainerLivenessProbe{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj GroupSpecContainerLivenessProbe

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerLivenessProbe{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*GroupSpecContainerLivenessProbe)(ptr) = obj
		} else {
			*(*GroupSpecContainerLivenessProbe)(ptr) = GroupSpecContainerLivenessProbe{}
		}
	default:
		iter.ReportError("decode GroupSpecContainerLivenessProbe", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecContainerReadinessProbeCodec struct {
}

func (GroupSpecContainerReadinessProbeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecContainerReadinessProbe)(ptr) == nil
}

func (GroupSpecContainerReadinessProbeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecContainerReadinessProbe)(ptr)
	var objs []GroupSpecContainerReadinessProbe
	if obj != nil {
		objs = []GroupSpecContainerReadinessProbe{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerReadinessProbe{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecContainerReadinessProbeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecContainerReadinessProbe)(ptr) = GroupSpecContainerReadinessProbe{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecContainerReadinessProbe

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerReadinessProbe{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecContainerReadinessProbe)(ptr) = objs[0]
			} else {
				*(*GroupSpecContainerReadinessProbe)(ptr) = GroupSpecContainerReadinessProbe{}
			}
		} else {
			*(*GroupSpecContainerReadinessProbe)(ptr) = GroupSpecContainerReadinessProbe{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj GroupSpecContainerReadinessProbe

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerReadinessProbe{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*GroupSpecContainerReadinessProbe)(ptr) = obj
		} else {
			*(*GroupSpecContainerReadinessProbe)(ptr) = GroupSpecContainerReadinessProbe{}
		}
	default:
		iter.ReportError("decode GroupSpecContainerReadinessProbe", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecContainerVolumeGitRepoCodec struct {
}

func (GroupSpecContainerVolumeGitRepoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecContainerVolumeGitRepo)(ptr) == nil
}

func (GroupSpecContainerVolumeGitRepoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecContainerVolumeGitRepo)(ptr)
	var objs []GroupSpecContainerVolumeGitRepo
	if obj != nil {
		objs = []GroupSpecContainerVolumeGitRepo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerVolumeGitRepo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecContainerVolumeGitRepoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecContainerVolumeGitRepo)(ptr) = GroupSpecContainerVolumeGitRepo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecContainerVolumeGitRepo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerVolumeGitRepo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecContainerVolumeGitRepo)(ptr) = objs[0]
			} else {
				*(*GroupSpecContainerVolumeGitRepo)(ptr) = GroupSpecContainerVolumeGitRepo{}
			}
		} else {
			*(*GroupSpecContainerVolumeGitRepo)(ptr) = GroupSpecContainerVolumeGitRepo{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj GroupSpecContainerVolumeGitRepo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerVolumeGitRepo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*GroupSpecContainerVolumeGitRepo)(ptr) = obj
		} else {
			*(*GroupSpecContainerVolumeGitRepo)(ptr) = GroupSpecContainerVolumeGitRepo{}
		}
	default:
		iter.ReportError("decode GroupSpecContainerVolumeGitRepo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecDiagnosticsCodec struct {
}

func (GroupSpecDiagnosticsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecDiagnostics)(ptr) == nil
}

func (GroupSpecDiagnosticsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecDiagnostics)(ptr)
	var objs []GroupSpecDiagnostics
	if obj != nil {
		objs = []GroupSpecDiagnostics{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDiagnostics{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecDiagnosticsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecDiagnostics)(ptr) = GroupSpecDiagnostics{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecDiagnostics

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDiagnostics{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecDiagnostics)(ptr) = objs[0]
			} else {
				*(*GroupSpecDiagnostics)(ptr) = GroupSpecDiagnostics{}
			}
		} else {
			*(*GroupSpecDiagnostics)(ptr) = GroupSpecDiagnostics{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj GroupSpecDiagnostics

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDiagnostics{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*GroupSpecDiagnostics)(ptr) = obj
		} else {
			*(*GroupSpecDiagnostics)(ptr) = GroupSpecDiagnostics{}
		}
	default:
		iter.ReportError("decode GroupSpecDiagnostics", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecDiagnosticsLogAnalyticsCodec struct {
}

func (GroupSpecDiagnosticsLogAnalyticsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecDiagnosticsLogAnalytics)(ptr) == nil
}

func (GroupSpecDiagnosticsLogAnalyticsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecDiagnosticsLogAnalytics)(ptr)
	var objs []GroupSpecDiagnosticsLogAnalytics
	if obj != nil {
		objs = []GroupSpecDiagnosticsLogAnalytics{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDiagnosticsLogAnalytics{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecDiagnosticsLogAnalyticsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecDiagnosticsLogAnalytics)(ptr) = GroupSpecDiagnosticsLogAnalytics{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecDiagnosticsLogAnalytics

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDiagnosticsLogAnalytics{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecDiagnosticsLogAnalytics)(ptr) = objs[0]
			} else {
				*(*GroupSpecDiagnosticsLogAnalytics)(ptr) = GroupSpecDiagnosticsLogAnalytics{}
			}
		} else {
			*(*GroupSpecDiagnosticsLogAnalytics)(ptr) = GroupSpecDiagnosticsLogAnalytics{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj GroupSpecDiagnosticsLogAnalytics

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDiagnosticsLogAnalytics{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*GroupSpecDiagnosticsLogAnalytics)(ptr) = obj
		} else {
			*(*GroupSpecDiagnosticsLogAnalytics)(ptr) = GroupSpecDiagnosticsLogAnalytics{}
		}
	default:
		iter.ReportError("decode GroupSpecDiagnosticsLogAnalytics", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecDnsConfigCodec struct {
}

func (GroupSpecDnsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecDnsConfig)(ptr) == nil
}

func (GroupSpecDnsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecDnsConfig)(ptr)
	var objs []GroupSpecDnsConfig
	if obj != nil {
		objs = []GroupSpecDnsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDnsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecDnsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecDnsConfig)(ptr) = GroupSpecDnsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecDnsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDnsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecDnsConfig)(ptr) = objs[0]
			} else {
				*(*GroupSpecDnsConfig)(ptr) = GroupSpecDnsConfig{}
			}
		} else {
			*(*GroupSpecDnsConfig)(ptr) = GroupSpecDnsConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj GroupSpecDnsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDnsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*GroupSpecDnsConfig)(ptr) = obj
		} else {
			*(*GroupSpecDnsConfig)(ptr) = GroupSpecDnsConfig{}
		}
	default:
		iter.ReportError("decode GroupSpecDnsConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecIdentityCodec struct {
}

func (GroupSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecIdentity)(ptr) == nil
}

func (GroupSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecIdentity)(ptr)
	var objs []GroupSpecIdentity
	if obj != nil {
		objs = []GroupSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecIdentity)(ptr) = GroupSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecIdentity)(ptr) = objs[0]
			} else {
				*(*GroupSpecIdentity)(ptr) = GroupSpecIdentity{}
			}
		} else {
			*(*GroupSpecIdentity)(ptr) = GroupSpecIdentity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj GroupSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*GroupSpecIdentity)(ptr) = obj
		} else {
			*(*GroupSpecIdentity)(ptr) = GroupSpecIdentity{}
		}
	default:
		iter.ReportError("decode GroupSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegistrySpecEncryptionCodec struct {
}

func (RegistrySpecEncryptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegistrySpecEncryption)(ptr) == nil
}

func (RegistrySpecEncryptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegistrySpecEncryption)(ptr)
	var objs []RegistrySpecEncryption
	if obj != nil {
		objs = []RegistrySpecEncryption{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecEncryption{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegistrySpecEncryptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegistrySpecEncryption)(ptr) = RegistrySpecEncryption{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegistrySpecEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegistrySpecEncryption)(ptr) = objs[0]
			} else {
				*(*RegistrySpecEncryption)(ptr) = RegistrySpecEncryption{}
			}
		} else {
			*(*RegistrySpecEncryption)(ptr) = RegistrySpecEncryption{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegistrySpecEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegistrySpecEncryption)(ptr) = obj
		} else {
			*(*RegistrySpecEncryption)(ptr) = RegistrySpecEncryption{}
		}
	default:
		iter.ReportError("decode RegistrySpecEncryption", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegistrySpecIdentityCodec struct {
}

func (RegistrySpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegistrySpecIdentity)(ptr) == nil
}

func (RegistrySpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegistrySpecIdentity)(ptr)
	var objs []RegistrySpecIdentity
	if obj != nil {
		objs = []RegistrySpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegistrySpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegistrySpecIdentity)(ptr) = RegistrySpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegistrySpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegistrySpecIdentity)(ptr) = objs[0]
			} else {
				*(*RegistrySpecIdentity)(ptr) = RegistrySpecIdentity{}
			}
		} else {
			*(*RegistrySpecIdentity)(ptr) = RegistrySpecIdentity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegistrySpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegistrySpecIdentity)(ptr) = obj
		} else {
			*(*RegistrySpecIdentity)(ptr) = RegistrySpecIdentity{}
		}
	default:
		iter.ReportError("decode RegistrySpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegistrySpecNetworkRuleSetCodec struct {
}

func (RegistrySpecNetworkRuleSetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegistrySpecNetworkRuleSet)(ptr) == nil
}

func (RegistrySpecNetworkRuleSetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegistrySpecNetworkRuleSet)(ptr)
	var objs []RegistrySpecNetworkRuleSet
	if obj != nil {
		objs = []RegistrySpecNetworkRuleSet{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecNetworkRuleSet{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegistrySpecNetworkRuleSetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegistrySpecNetworkRuleSet)(ptr) = RegistrySpecNetworkRuleSet{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegistrySpecNetworkRuleSet

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecNetworkRuleSet{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegistrySpecNetworkRuleSet)(ptr) = objs[0]
			} else {
				*(*RegistrySpecNetworkRuleSet)(ptr) = RegistrySpecNetworkRuleSet{}
			}
		} else {
			*(*RegistrySpecNetworkRuleSet)(ptr) = RegistrySpecNetworkRuleSet{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegistrySpecNetworkRuleSet

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecNetworkRuleSet{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegistrySpecNetworkRuleSet)(ptr) = obj
		} else {
			*(*RegistrySpecNetworkRuleSet)(ptr) = RegistrySpecNetworkRuleSet{}
		}
	default:
		iter.ReportError("decode RegistrySpecNetworkRuleSet", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegistrySpecRetentionPolicyCodec struct {
}

func (RegistrySpecRetentionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegistrySpecRetentionPolicy)(ptr) == nil
}

func (RegistrySpecRetentionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegistrySpecRetentionPolicy)(ptr)
	var objs []RegistrySpecRetentionPolicy
	if obj != nil {
		objs = []RegistrySpecRetentionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecRetentionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegistrySpecRetentionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegistrySpecRetentionPolicy)(ptr) = RegistrySpecRetentionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegistrySpecRetentionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecRetentionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegistrySpecRetentionPolicy)(ptr) = objs[0]
			} else {
				*(*RegistrySpecRetentionPolicy)(ptr) = RegistrySpecRetentionPolicy{}
			}
		} else {
			*(*RegistrySpecRetentionPolicy)(ptr) = RegistrySpecRetentionPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegistrySpecRetentionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecRetentionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegistrySpecRetentionPolicy)(ptr) = obj
		} else {
			*(*RegistrySpecRetentionPolicy)(ptr) = RegistrySpecRetentionPolicy{}
		}
	default:
		iter.ReportError("decode RegistrySpecRetentionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegistrySpecTrustPolicyCodec struct {
}

func (RegistrySpecTrustPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegistrySpecTrustPolicy)(ptr) == nil
}

func (RegistrySpecTrustPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegistrySpecTrustPolicy)(ptr)
	var objs []RegistrySpecTrustPolicy
	if obj != nil {
		objs = []RegistrySpecTrustPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecTrustPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegistrySpecTrustPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegistrySpecTrustPolicy)(ptr) = RegistrySpecTrustPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegistrySpecTrustPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecTrustPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegistrySpecTrustPolicy)(ptr) = objs[0]
			} else {
				*(*RegistrySpecTrustPolicy)(ptr) = RegistrySpecTrustPolicy{}
			}
		} else {
			*(*RegistrySpecTrustPolicy)(ptr) = RegistrySpecTrustPolicy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegistrySpecTrustPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecTrustPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegistrySpecTrustPolicy)(ptr) = obj
		} else {
			*(*RegistrySpecTrustPolicy)(ptr) = RegistrySpecTrustPolicy{}
		}
	default:
		iter.ReportError("decode RegistrySpecTrustPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegistryTaskSpecAgentSettingCodec struct {
}

func (RegistryTaskSpecAgentSettingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegistryTaskSpecAgentSetting)(ptr) == nil
}

func (RegistryTaskSpecAgentSettingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegistryTaskSpecAgentSetting)(ptr)
	var objs []RegistryTaskSpecAgentSetting
	if obj != nil {
		objs = []RegistryTaskSpecAgentSetting{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecAgentSetting{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegistryTaskSpecAgentSettingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegistryTaskSpecAgentSetting)(ptr) = RegistryTaskSpecAgentSetting{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegistryTaskSpecAgentSetting

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecAgentSetting{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegistryTaskSpecAgentSetting)(ptr) = objs[0]
			} else {
				*(*RegistryTaskSpecAgentSetting)(ptr) = RegistryTaskSpecAgentSetting{}
			}
		} else {
			*(*RegistryTaskSpecAgentSetting)(ptr) = RegistryTaskSpecAgentSetting{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegistryTaskSpecAgentSetting

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecAgentSetting{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegistryTaskSpecAgentSetting)(ptr) = obj
		} else {
			*(*RegistryTaskSpecAgentSetting)(ptr) = RegistryTaskSpecAgentSetting{}
		}
	default:
		iter.ReportError("decode RegistryTaskSpecAgentSetting", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegistryTaskSpecBaseImageTriggerCodec struct {
}

func (RegistryTaskSpecBaseImageTriggerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegistryTaskSpecBaseImageTrigger)(ptr) == nil
}

func (RegistryTaskSpecBaseImageTriggerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegistryTaskSpecBaseImageTrigger)(ptr)
	var objs []RegistryTaskSpecBaseImageTrigger
	if obj != nil {
		objs = []RegistryTaskSpecBaseImageTrigger{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecBaseImageTrigger{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegistryTaskSpecBaseImageTriggerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegistryTaskSpecBaseImageTrigger)(ptr) = RegistryTaskSpecBaseImageTrigger{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegistryTaskSpecBaseImageTrigger

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecBaseImageTrigger{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegistryTaskSpecBaseImageTrigger)(ptr) = objs[0]
			} else {
				*(*RegistryTaskSpecBaseImageTrigger)(ptr) = RegistryTaskSpecBaseImageTrigger{}
			}
		} else {
			*(*RegistryTaskSpecBaseImageTrigger)(ptr) = RegistryTaskSpecBaseImageTrigger{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegistryTaskSpecBaseImageTrigger

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecBaseImageTrigger{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegistryTaskSpecBaseImageTrigger)(ptr) = obj
		} else {
			*(*RegistryTaskSpecBaseImageTrigger)(ptr) = RegistryTaskSpecBaseImageTrigger{}
		}
	default:
		iter.ReportError("decode RegistryTaskSpecBaseImageTrigger", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegistryTaskSpecDockerStepCodec struct {
}

func (RegistryTaskSpecDockerStepCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegistryTaskSpecDockerStep)(ptr) == nil
}

func (RegistryTaskSpecDockerStepCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegistryTaskSpecDockerStep)(ptr)
	var objs []RegistryTaskSpecDockerStep
	if obj != nil {
		objs = []RegistryTaskSpecDockerStep{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecDockerStep{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegistryTaskSpecDockerStepCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegistryTaskSpecDockerStep)(ptr) = RegistryTaskSpecDockerStep{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegistryTaskSpecDockerStep

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecDockerStep{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegistryTaskSpecDockerStep)(ptr) = objs[0]
			} else {
				*(*RegistryTaskSpecDockerStep)(ptr) = RegistryTaskSpecDockerStep{}
			}
		} else {
			*(*RegistryTaskSpecDockerStep)(ptr) = RegistryTaskSpecDockerStep{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegistryTaskSpecDockerStep

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecDockerStep{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegistryTaskSpecDockerStep)(ptr) = obj
		} else {
			*(*RegistryTaskSpecDockerStep)(ptr) = RegistryTaskSpecDockerStep{}
		}
	default:
		iter.ReportError("decode RegistryTaskSpecDockerStep", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegistryTaskSpecEncodedStepCodec struct {
}

func (RegistryTaskSpecEncodedStepCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegistryTaskSpecEncodedStep)(ptr) == nil
}

func (RegistryTaskSpecEncodedStepCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegistryTaskSpecEncodedStep)(ptr)
	var objs []RegistryTaskSpecEncodedStep
	if obj != nil {
		objs = []RegistryTaskSpecEncodedStep{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecEncodedStep{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegistryTaskSpecEncodedStepCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegistryTaskSpecEncodedStep)(ptr) = RegistryTaskSpecEncodedStep{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegistryTaskSpecEncodedStep

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecEncodedStep{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegistryTaskSpecEncodedStep)(ptr) = objs[0]
			} else {
				*(*RegistryTaskSpecEncodedStep)(ptr) = RegistryTaskSpecEncodedStep{}
			}
		} else {
			*(*RegistryTaskSpecEncodedStep)(ptr) = RegistryTaskSpecEncodedStep{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegistryTaskSpecEncodedStep

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecEncodedStep{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegistryTaskSpecEncodedStep)(ptr) = obj
		} else {
			*(*RegistryTaskSpecEncodedStep)(ptr) = RegistryTaskSpecEncodedStep{}
		}
	default:
		iter.ReportError("decode RegistryTaskSpecEncodedStep", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegistryTaskSpecFileStepCodec struct {
}

func (RegistryTaskSpecFileStepCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegistryTaskSpecFileStep)(ptr) == nil
}

func (RegistryTaskSpecFileStepCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegistryTaskSpecFileStep)(ptr)
	var objs []RegistryTaskSpecFileStep
	if obj != nil {
		objs = []RegistryTaskSpecFileStep{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecFileStep{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegistryTaskSpecFileStepCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegistryTaskSpecFileStep)(ptr) = RegistryTaskSpecFileStep{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegistryTaskSpecFileStep

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecFileStep{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegistryTaskSpecFileStep)(ptr) = objs[0]
			} else {
				*(*RegistryTaskSpecFileStep)(ptr) = RegistryTaskSpecFileStep{}
			}
		} else {
			*(*RegistryTaskSpecFileStep)(ptr) = RegistryTaskSpecFileStep{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegistryTaskSpecFileStep

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecFileStep{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegistryTaskSpecFileStep)(ptr) = obj
		} else {
			*(*RegistryTaskSpecFileStep)(ptr) = RegistryTaskSpecFileStep{}
		}
	default:
		iter.ReportError("decode RegistryTaskSpecFileStep", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegistryTaskSpecIdentityCodec struct {
}

func (RegistryTaskSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegistryTaskSpecIdentity)(ptr) == nil
}

func (RegistryTaskSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegistryTaskSpecIdentity)(ptr)
	var objs []RegistryTaskSpecIdentity
	if obj != nil {
		objs = []RegistryTaskSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegistryTaskSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegistryTaskSpecIdentity)(ptr) = RegistryTaskSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegistryTaskSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegistryTaskSpecIdentity)(ptr) = objs[0]
			} else {
				*(*RegistryTaskSpecIdentity)(ptr) = RegistryTaskSpecIdentity{}
			}
		} else {
			*(*RegistryTaskSpecIdentity)(ptr) = RegistryTaskSpecIdentity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegistryTaskSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegistryTaskSpecIdentity)(ptr) = obj
		} else {
			*(*RegistryTaskSpecIdentity)(ptr) = RegistryTaskSpecIdentity{}
		}
	default:
		iter.ReportError("decode RegistryTaskSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegistryTaskSpecPlatformCodec struct {
}

func (RegistryTaskSpecPlatformCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegistryTaskSpecPlatform)(ptr) == nil
}

func (RegistryTaskSpecPlatformCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegistryTaskSpecPlatform)(ptr)
	var objs []RegistryTaskSpecPlatform
	if obj != nil {
		objs = []RegistryTaskSpecPlatform{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecPlatform{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegistryTaskSpecPlatformCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegistryTaskSpecPlatform)(ptr) = RegistryTaskSpecPlatform{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegistryTaskSpecPlatform

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecPlatform{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegistryTaskSpecPlatform)(ptr) = objs[0]
			} else {
				*(*RegistryTaskSpecPlatform)(ptr) = RegistryTaskSpecPlatform{}
			}
		} else {
			*(*RegistryTaskSpecPlatform)(ptr) = RegistryTaskSpecPlatform{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegistryTaskSpecPlatform

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecPlatform{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegistryTaskSpecPlatform)(ptr) = obj
		} else {
			*(*RegistryTaskSpecPlatform)(ptr) = RegistryTaskSpecPlatform{}
		}
	default:
		iter.ReportError("decode RegistryTaskSpecPlatform", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegistryTaskSpecRegistryCredentialCodec struct {
}

func (RegistryTaskSpecRegistryCredentialCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegistryTaskSpecRegistryCredential)(ptr) == nil
}

func (RegistryTaskSpecRegistryCredentialCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegistryTaskSpecRegistryCredential)(ptr)
	var objs []RegistryTaskSpecRegistryCredential
	if obj != nil {
		objs = []RegistryTaskSpecRegistryCredential{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecRegistryCredential{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegistryTaskSpecRegistryCredentialCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegistryTaskSpecRegistryCredential)(ptr) = RegistryTaskSpecRegistryCredential{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegistryTaskSpecRegistryCredential

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecRegistryCredential{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegistryTaskSpecRegistryCredential)(ptr) = objs[0]
			} else {
				*(*RegistryTaskSpecRegistryCredential)(ptr) = RegistryTaskSpecRegistryCredential{}
			}
		} else {
			*(*RegistryTaskSpecRegistryCredential)(ptr) = RegistryTaskSpecRegistryCredential{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegistryTaskSpecRegistryCredential

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecRegistryCredential{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegistryTaskSpecRegistryCredential)(ptr) = obj
		} else {
			*(*RegistryTaskSpecRegistryCredential)(ptr) = RegistryTaskSpecRegistryCredential{}
		}
	default:
		iter.ReportError("decode RegistryTaskSpecRegistryCredential", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegistryTaskSpecRegistryCredentialSourceCodec struct {
}

func (RegistryTaskSpecRegistryCredentialSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegistryTaskSpecRegistryCredentialSource)(ptr) == nil
}

func (RegistryTaskSpecRegistryCredentialSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegistryTaskSpecRegistryCredentialSource)(ptr)
	var objs []RegistryTaskSpecRegistryCredentialSource
	if obj != nil {
		objs = []RegistryTaskSpecRegistryCredentialSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecRegistryCredentialSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegistryTaskSpecRegistryCredentialSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegistryTaskSpecRegistryCredentialSource)(ptr) = RegistryTaskSpecRegistryCredentialSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegistryTaskSpecRegistryCredentialSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecRegistryCredentialSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegistryTaskSpecRegistryCredentialSource)(ptr) = objs[0]
			} else {
				*(*RegistryTaskSpecRegistryCredentialSource)(ptr) = RegistryTaskSpecRegistryCredentialSource{}
			}
		} else {
			*(*RegistryTaskSpecRegistryCredentialSource)(ptr) = RegistryTaskSpecRegistryCredentialSource{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegistryTaskSpecRegistryCredentialSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecRegistryCredentialSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegistryTaskSpecRegistryCredentialSource)(ptr) = obj
		} else {
			*(*RegistryTaskSpecRegistryCredentialSource)(ptr) = RegistryTaskSpecRegistryCredentialSource{}
		}
	default:
		iter.ReportError("decode RegistryTaskSpecRegistryCredentialSource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegistryTaskSpecSourceTriggerAuthenticationCodec struct {
}

func (RegistryTaskSpecSourceTriggerAuthenticationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegistryTaskSpecSourceTriggerAuthentication)(ptr) == nil
}

func (RegistryTaskSpecSourceTriggerAuthenticationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegistryTaskSpecSourceTriggerAuthentication)(ptr)
	var objs []RegistryTaskSpecSourceTriggerAuthentication
	if obj != nil {
		objs = []RegistryTaskSpecSourceTriggerAuthentication{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecSourceTriggerAuthentication{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegistryTaskSpecSourceTriggerAuthenticationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegistryTaskSpecSourceTriggerAuthentication)(ptr) = RegistryTaskSpecSourceTriggerAuthentication{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegistryTaskSpecSourceTriggerAuthentication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecSourceTriggerAuthentication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegistryTaskSpecSourceTriggerAuthentication)(ptr) = objs[0]
			} else {
				*(*RegistryTaskSpecSourceTriggerAuthentication)(ptr) = RegistryTaskSpecSourceTriggerAuthentication{}
			}
		} else {
			*(*RegistryTaskSpecSourceTriggerAuthentication)(ptr) = RegistryTaskSpecSourceTriggerAuthentication{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RegistryTaskSpecSourceTriggerAuthentication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistryTaskSpecSourceTriggerAuthentication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RegistryTaskSpecSourceTriggerAuthentication)(ptr) = obj
		} else {
			*(*RegistryTaskSpecSourceTriggerAuthentication)(ptr) = RegistryTaskSpecSourceTriggerAuthentication{}
		}
	default:
		iter.ReportError("decode RegistryTaskSpecSourceTriggerAuthentication", "unexpected JSON type")
	}
}

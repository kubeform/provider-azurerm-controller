/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package provider

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeatures{}).Type1()):                       AzurermSpecFeaturesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesApiManagement{}).Type1()):          AzurermSpecFeaturesApiManagementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesCognitiveAccount{}).Type1()):       AzurermSpecFeaturesCognitiveAccountCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesKeyVault{}).Type1()):               AzurermSpecFeaturesKeyVaultCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesLogAnalyticsWorkspace{}).Type1()):  AzurermSpecFeaturesLogAnalyticsWorkspaceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesNetwork{}).Type1()):                AzurermSpecFeaturesNetworkCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesResourceGroup{}).Type1()):          AzurermSpecFeaturesResourceGroupCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesTemplateDeployment{}).Type1()):     AzurermSpecFeaturesTemplateDeploymentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesVirtualMachine{}).Type1()):         AzurermSpecFeaturesVirtualMachineCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesVirtualMachineScaleSet{}).Type1()): AzurermSpecFeaturesVirtualMachineScaleSetCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeatures{}).Type1()):                       AzurermSpecFeaturesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesApiManagement{}).Type1()):          AzurermSpecFeaturesApiManagementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesCognitiveAccount{}).Type1()):       AzurermSpecFeaturesCognitiveAccountCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesKeyVault{}).Type1()):               AzurermSpecFeaturesKeyVaultCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesLogAnalyticsWorkspace{}).Type1()):  AzurermSpecFeaturesLogAnalyticsWorkspaceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesNetwork{}).Type1()):                AzurermSpecFeaturesNetworkCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesResourceGroup{}).Type1()):          AzurermSpecFeaturesResourceGroupCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesTemplateDeployment{}).Type1()):     AzurermSpecFeaturesTemplateDeploymentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesVirtualMachine{}).Type1()):         AzurermSpecFeaturesVirtualMachineCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesVirtualMachineScaleSet{}).Type1()): AzurermSpecFeaturesVirtualMachineScaleSetCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AzurermSpecFeaturesCodec struct {
}

func (AzurermSpecFeaturesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzurermSpecFeatures)(ptr) == nil
}

func (AzurermSpecFeaturesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzurermSpecFeatures)(ptr)
	var objs []AzurermSpecFeatures
	if obj != nil {
		objs = []AzurermSpecFeatures{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeatures{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzurermSpecFeaturesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzurermSpecFeatures)(ptr) = AzurermSpecFeatures{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzurermSpecFeatures

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeatures{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzurermSpecFeatures)(ptr) = objs[0]
			} else {
				*(*AzurermSpecFeatures)(ptr) = AzurermSpecFeatures{}
			}
		} else {
			*(*AzurermSpecFeatures)(ptr) = AzurermSpecFeatures{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzurermSpecFeatures

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeatures{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzurermSpecFeatures)(ptr) = obj
		} else {
			*(*AzurermSpecFeatures)(ptr) = AzurermSpecFeatures{}
		}
	default:
		iter.ReportError("decode AzurermSpecFeatures", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzurermSpecFeaturesApiManagementCodec struct {
}

func (AzurermSpecFeaturesApiManagementCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzurermSpecFeaturesApiManagement)(ptr) == nil
}

func (AzurermSpecFeaturesApiManagementCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzurermSpecFeaturesApiManagement)(ptr)
	var objs []AzurermSpecFeaturesApiManagement
	if obj != nil {
		objs = []AzurermSpecFeaturesApiManagement{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesApiManagement{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzurermSpecFeaturesApiManagementCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzurermSpecFeaturesApiManagement)(ptr) = AzurermSpecFeaturesApiManagement{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzurermSpecFeaturesApiManagement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesApiManagement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzurermSpecFeaturesApiManagement)(ptr) = objs[0]
			} else {
				*(*AzurermSpecFeaturesApiManagement)(ptr) = AzurermSpecFeaturesApiManagement{}
			}
		} else {
			*(*AzurermSpecFeaturesApiManagement)(ptr) = AzurermSpecFeaturesApiManagement{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzurermSpecFeaturesApiManagement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesApiManagement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzurermSpecFeaturesApiManagement)(ptr) = obj
		} else {
			*(*AzurermSpecFeaturesApiManagement)(ptr) = AzurermSpecFeaturesApiManagement{}
		}
	default:
		iter.ReportError("decode AzurermSpecFeaturesApiManagement", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzurermSpecFeaturesCognitiveAccountCodec struct {
}

func (AzurermSpecFeaturesCognitiveAccountCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzurermSpecFeaturesCognitiveAccount)(ptr) == nil
}

func (AzurermSpecFeaturesCognitiveAccountCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzurermSpecFeaturesCognitiveAccount)(ptr)
	var objs []AzurermSpecFeaturesCognitiveAccount
	if obj != nil {
		objs = []AzurermSpecFeaturesCognitiveAccount{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesCognitiveAccount{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzurermSpecFeaturesCognitiveAccountCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzurermSpecFeaturesCognitiveAccount)(ptr) = AzurermSpecFeaturesCognitiveAccount{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzurermSpecFeaturesCognitiveAccount

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesCognitiveAccount{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzurermSpecFeaturesCognitiveAccount)(ptr) = objs[0]
			} else {
				*(*AzurermSpecFeaturesCognitiveAccount)(ptr) = AzurermSpecFeaturesCognitiveAccount{}
			}
		} else {
			*(*AzurermSpecFeaturesCognitiveAccount)(ptr) = AzurermSpecFeaturesCognitiveAccount{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzurermSpecFeaturesCognitiveAccount

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesCognitiveAccount{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzurermSpecFeaturesCognitiveAccount)(ptr) = obj
		} else {
			*(*AzurermSpecFeaturesCognitiveAccount)(ptr) = AzurermSpecFeaturesCognitiveAccount{}
		}
	default:
		iter.ReportError("decode AzurermSpecFeaturesCognitiveAccount", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzurermSpecFeaturesKeyVaultCodec struct {
}

func (AzurermSpecFeaturesKeyVaultCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzurermSpecFeaturesKeyVault)(ptr) == nil
}

func (AzurermSpecFeaturesKeyVaultCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzurermSpecFeaturesKeyVault)(ptr)
	var objs []AzurermSpecFeaturesKeyVault
	if obj != nil {
		objs = []AzurermSpecFeaturesKeyVault{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesKeyVault{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzurermSpecFeaturesKeyVaultCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzurermSpecFeaturesKeyVault)(ptr) = AzurermSpecFeaturesKeyVault{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzurermSpecFeaturesKeyVault

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesKeyVault{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzurermSpecFeaturesKeyVault)(ptr) = objs[0]
			} else {
				*(*AzurermSpecFeaturesKeyVault)(ptr) = AzurermSpecFeaturesKeyVault{}
			}
		} else {
			*(*AzurermSpecFeaturesKeyVault)(ptr) = AzurermSpecFeaturesKeyVault{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzurermSpecFeaturesKeyVault

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesKeyVault{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzurermSpecFeaturesKeyVault)(ptr) = obj
		} else {
			*(*AzurermSpecFeaturesKeyVault)(ptr) = AzurermSpecFeaturesKeyVault{}
		}
	default:
		iter.ReportError("decode AzurermSpecFeaturesKeyVault", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzurermSpecFeaturesLogAnalyticsWorkspaceCodec struct {
}

func (AzurermSpecFeaturesLogAnalyticsWorkspaceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzurermSpecFeaturesLogAnalyticsWorkspace)(ptr) == nil
}

func (AzurermSpecFeaturesLogAnalyticsWorkspaceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzurermSpecFeaturesLogAnalyticsWorkspace)(ptr)
	var objs []AzurermSpecFeaturesLogAnalyticsWorkspace
	if obj != nil {
		objs = []AzurermSpecFeaturesLogAnalyticsWorkspace{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesLogAnalyticsWorkspace{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzurermSpecFeaturesLogAnalyticsWorkspaceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzurermSpecFeaturesLogAnalyticsWorkspace)(ptr) = AzurermSpecFeaturesLogAnalyticsWorkspace{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzurermSpecFeaturesLogAnalyticsWorkspace

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesLogAnalyticsWorkspace{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzurermSpecFeaturesLogAnalyticsWorkspace)(ptr) = objs[0]
			} else {
				*(*AzurermSpecFeaturesLogAnalyticsWorkspace)(ptr) = AzurermSpecFeaturesLogAnalyticsWorkspace{}
			}
		} else {
			*(*AzurermSpecFeaturesLogAnalyticsWorkspace)(ptr) = AzurermSpecFeaturesLogAnalyticsWorkspace{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzurermSpecFeaturesLogAnalyticsWorkspace

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesLogAnalyticsWorkspace{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzurermSpecFeaturesLogAnalyticsWorkspace)(ptr) = obj
		} else {
			*(*AzurermSpecFeaturesLogAnalyticsWorkspace)(ptr) = AzurermSpecFeaturesLogAnalyticsWorkspace{}
		}
	default:
		iter.ReportError("decode AzurermSpecFeaturesLogAnalyticsWorkspace", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzurermSpecFeaturesNetworkCodec struct {
}

func (AzurermSpecFeaturesNetworkCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzurermSpecFeaturesNetwork)(ptr) == nil
}

func (AzurermSpecFeaturesNetworkCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzurermSpecFeaturesNetwork)(ptr)
	var objs []AzurermSpecFeaturesNetwork
	if obj != nil {
		objs = []AzurermSpecFeaturesNetwork{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesNetwork{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzurermSpecFeaturesNetworkCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzurermSpecFeaturesNetwork)(ptr) = AzurermSpecFeaturesNetwork{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzurermSpecFeaturesNetwork

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesNetwork{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzurermSpecFeaturesNetwork)(ptr) = objs[0]
			} else {
				*(*AzurermSpecFeaturesNetwork)(ptr) = AzurermSpecFeaturesNetwork{}
			}
		} else {
			*(*AzurermSpecFeaturesNetwork)(ptr) = AzurermSpecFeaturesNetwork{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzurermSpecFeaturesNetwork

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesNetwork{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzurermSpecFeaturesNetwork)(ptr) = obj
		} else {
			*(*AzurermSpecFeaturesNetwork)(ptr) = AzurermSpecFeaturesNetwork{}
		}
	default:
		iter.ReportError("decode AzurermSpecFeaturesNetwork", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzurermSpecFeaturesResourceGroupCodec struct {
}

func (AzurermSpecFeaturesResourceGroupCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzurermSpecFeaturesResourceGroup)(ptr) == nil
}

func (AzurermSpecFeaturesResourceGroupCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzurermSpecFeaturesResourceGroup)(ptr)
	var objs []AzurermSpecFeaturesResourceGroup
	if obj != nil {
		objs = []AzurermSpecFeaturesResourceGroup{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesResourceGroup{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzurermSpecFeaturesResourceGroupCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzurermSpecFeaturesResourceGroup)(ptr) = AzurermSpecFeaturesResourceGroup{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzurermSpecFeaturesResourceGroup

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesResourceGroup{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzurermSpecFeaturesResourceGroup)(ptr) = objs[0]
			} else {
				*(*AzurermSpecFeaturesResourceGroup)(ptr) = AzurermSpecFeaturesResourceGroup{}
			}
		} else {
			*(*AzurermSpecFeaturesResourceGroup)(ptr) = AzurermSpecFeaturesResourceGroup{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzurermSpecFeaturesResourceGroup

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesResourceGroup{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzurermSpecFeaturesResourceGroup)(ptr) = obj
		} else {
			*(*AzurermSpecFeaturesResourceGroup)(ptr) = AzurermSpecFeaturesResourceGroup{}
		}
	default:
		iter.ReportError("decode AzurermSpecFeaturesResourceGroup", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzurermSpecFeaturesTemplateDeploymentCodec struct {
}

func (AzurermSpecFeaturesTemplateDeploymentCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzurermSpecFeaturesTemplateDeployment)(ptr) == nil
}

func (AzurermSpecFeaturesTemplateDeploymentCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzurermSpecFeaturesTemplateDeployment)(ptr)
	var objs []AzurermSpecFeaturesTemplateDeployment
	if obj != nil {
		objs = []AzurermSpecFeaturesTemplateDeployment{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesTemplateDeployment{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzurermSpecFeaturesTemplateDeploymentCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzurermSpecFeaturesTemplateDeployment)(ptr) = AzurermSpecFeaturesTemplateDeployment{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzurermSpecFeaturesTemplateDeployment

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesTemplateDeployment{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzurermSpecFeaturesTemplateDeployment)(ptr) = objs[0]
			} else {
				*(*AzurermSpecFeaturesTemplateDeployment)(ptr) = AzurermSpecFeaturesTemplateDeployment{}
			}
		} else {
			*(*AzurermSpecFeaturesTemplateDeployment)(ptr) = AzurermSpecFeaturesTemplateDeployment{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzurermSpecFeaturesTemplateDeployment

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesTemplateDeployment{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzurermSpecFeaturesTemplateDeployment)(ptr) = obj
		} else {
			*(*AzurermSpecFeaturesTemplateDeployment)(ptr) = AzurermSpecFeaturesTemplateDeployment{}
		}
	default:
		iter.ReportError("decode AzurermSpecFeaturesTemplateDeployment", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzurermSpecFeaturesVirtualMachineCodec struct {
}

func (AzurermSpecFeaturesVirtualMachineCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzurermSpecFeaturesVirtualMachine)(ptr) == nil
}

func (AzurermSpecFeaturesVirtualMachineCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzurermSpecFeaturesVirtualMachine)(ptr)
	var objs []AzurermSpecFeaturesVirtualMachine
	if obj != nil {
		objs = []AzurermSpecFeaturesVirtualMachine{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesVirtualMachine{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzurermSpecFeaturesVirtualMachineCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzurermSpecFeaturesVirtualMachine)(ptr) = AzurermSpecFeaturesVirtualMachine{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzurermSpecFeaturesVirtualMachine

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesVirtualMachine{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzurermSpecFeaturesVirtualMachine)(ptr) = objs[0]
			} else {
				*(*AzurermSpecFeaturesVirtualMachine)(ptr) = AzurermSpecFeaturesVirtualMachine{}
			}
		} else {
			*(*AzurermSpecFeaturesVirtualMachine)(ptr) = AzurermSpecFeaturesVirtualMachine{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzurermSpecFeaturesVirtualMachine

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesVirtualMachine{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzurermSpecFeaturesVirtualMachine)(ptr) = obj
		} else {
			*(*AzurermSpecFeaturesVirtualMachine)(ptr) = AzurermSpecFeaturesVirtualMachine{}
		}
	default:
		iter.ReportError("decode AzurermSpecFeaturesVirtualMachine", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AzurermSpecFeaturesVirtualMachineScaleSetCodec struct {
}

func (AzurermSpecFeaturesVirtualMachineScaleSetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AzurermSpecFeaturesVirtualMachineScaleSet)(ptr) == nil
}

func (AzurermSpecFeaturesVirtualMachineScaleSetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AzurermSpecFeaturesVirtualMachineScaleSet)(ptr)
	var objs []AzurermSpecFeaturesVirtualMachineScaleSet
	if obj != nil {
		objs = []AzurermSpecFeaturesVirtualMachineScaleSet{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesVirtualMachineScaleSet{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AzurermSpecFeaturesVirtualMachineScaleSetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AzurermSpecFeaturesVirtualMachineScaleSet)(ptr) = AzurermSpecFeaturesVirtualMachineScaleSet{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AzurermSpecFeaturesVirtualMachineScaleSet

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesVirtualMachineScaleSet{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AzurermSpecFeaturesVirtualMachineScaleSet)(ptr) = objs[0]
			} else {
				*(*AzurermSpecFeaturesVirtualMachineScaleSet)(ptr) = AzurermSpecFeaturesVirtualMachineScaleSet{}
			}
		} else {
			*(*AzurermSpecFeaturesVirtualMachineScaleSet)(ptr) = AzurermSpecFeaturesVirtualMachineScaleSet{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AzurermSpecFeaturesVirtualMachineScaleSet

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AzurermSpecFeaturesVirtualMachineScaleSet{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AzurermSpecFeaturesVirtualMachineScaleSet)(ptr) = obj
		} else {
			*(*AzurermSpecFeaturesVirtualMachineScaleSet)(ptr) = AzurermSpecFeaturesVirtualMachineScaleSet{}
		}
	default:
		iter.ReportError("decode AzurermSpecFeaturesVirtualMachineScaleSet", "unexpected JSON type")
	}
}
